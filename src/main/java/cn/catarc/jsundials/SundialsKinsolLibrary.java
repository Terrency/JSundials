package cn.catarc.jsundials;

import cn.catarc.jsundials.SundialsSunmatrixdenseLibrary.*;
import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;

import java.nio.LongBuffer;
/**
 * JNA Wrapper for library <b>SundialsKinsol</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface SundialsKinsolLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "SundialsKinsol";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(SundialsKinsolLibrary.JNA_LIBRARY_NAME);
	public static final SundialsKinsolLibrary INSTANCE = (SundialsKinsolLibrary)Native.loadLibrary(SundialsKinsolLibrary.JNA_LIBRARY_NAME, SundialsKinsolLibrary.class);
	public static final int SUN_PREC_NONE = 0;
	public static final int SUN_PREC_LEFT = 1;
	public static final int SUN_PREC_RIGHT = 2;
	public static final int SUN_PREC_BOTH = 3;
	public static final int SUN_MODIFIED_GS = 1;
	public static final int SUN_CLASSICAL_GS = 2;
	/**
	 * <i>native declaration : include\sundials\sundials_linearsolver.h</i><br>
	 * enum values
	 */
	public static interface SUNLinearSolver_Type {
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:12</i> */
		public static final int SUNLINEARSOLVER_DIRECT = 0;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:13</i> */
		public static final int SUNLINEARSOLVER_ITERATIVE = 1;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:14</i> */
		public static final int SUNLINEARSOLVER_MATRIX_ITERATIVE = 2;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:15</i> */
		public static final int SUNLINEARSOLVER_MATRIX_EMBEDDED = 3;
	};
	/**
	 * <i>native declaration : include\sundials\sundials_linearsolver.h</i><br>
	 * enum values
	 */
	public static interface SUNLinearSolver_ID {
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:20</i> */
		public static final int SUNLINEARSOLVER_BAND = 0;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:21</i> */
		public static final int SUNLINEARSOLVER_DENSE = 1;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:22</i> */
		public static final int SUNLINEARSOLVER_KLU = 2;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:23</i> */
		public static final int SUNLINEARSOLVER_LAPACKBAND = 3;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:24</i> */
		public static final int SUNLINEARSOLVER_LAPACKDENSE = 4;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:25</i> */
		public static final int SUNLINEARSOLVER_PCG = 5;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:26</i> */
		public static final int SUNLINEARSOLVER_SPBCGS = 6;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:27</i> */
		public static final int SUNLINEARSOLVER_SPFGMR = 7;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:28</i> */
		public static final int SUNLINEARSOLVER_SPGMR = 8;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:29</i> */
		public static final int SUNLINEARSOLVER_SPTFQMR = 9;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:30</i> */
		public static final int SUNLINEARSOLVER_SUPERLUDIST = 10;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:31</i> */
		public static final int SUNLINEARSOLVER_SUPERLUMT = 11;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:32</i> */
		public static final int SUNLINEARSOLVER_CUSOLVERSP_BATCHQR = 12;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:33</i> */
		public static final int SUNLINEARSOLVER_MAGMADENSE = 13;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:34</i> */
		public static final int SUNLINEARSOLVER_ONEMKLDENSE = 14;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:35</i> */
		public static final int SUNLINEARSOLVER_GINKGO = 15;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:36</i> */
		public static final int SUNLINEARSOLVER_KOKKOSDENSE = 16;
		/** <i>native declaration : include\sundials\sundials_linearsolver.h:37</i> */
		public static final int SUNLINEARSOLVER_CUSTOM = 17;
	};
	/**
	 * <i>native declaration : include\sundials\sundials_matrix.h</i><br>
	 * enum values
	 */
	public static interface SUNMatrix_ID {
		/** <i>native declaration : include\sundials\sundials_matrix.h:12</i> */
		public static final int SUNMATRIX_DENSE = 0;
		/** <i>native declaration : include\sundials\sundials_matrix.h:13</i> */
		public static final int SUNMATRIX_MAGMADENSE = 1;
		/** <i>native declaration : include\sundials\sundials_matrix.h:14</i> */
		public static final int SUNMATRIX_ONEMKLDENSE = 2;
		/** <i>native declaration : include\sundials\sundials_matrix.h:15</i> */
		public static final int SUNMATRIX_BAND = 3;
		/** <i>native declaration : include\sundials\sundials_matrix.h:16</i> */
		public static final int SUNMATRIX_SPARSE = 4;
		/** <i>native declaration : include\sundials\sundials_matrix.h:17</i> */
		public static final int SUNMATRIX_SLUNRLOC = 5;
		/** <i>native declaration : include\sundials\sundials_matrix.h:18</i> */
		public static final int SUNMATRIX_CUSPARSE = 6;
		/** <i>native declaration : include\sundials\sundials_matrix.h:19</i> */
		public static final int SUNMATRIX_GINKGO = 7;
		/** <i>native declaration : include\sundials\sundials_matrix.h:20</i> */
		public static final int SUNMATRIX_KOKKOSDENSE = 8;
		/** <i>native declaration : include\sundials\sundials_matrix.h:21</i> */
		public static final int SUNMATRIX_CUSTOM = 9;
	};
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_SUCCESS = (int)0;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_INITIAL_GUESS_OK = (int)1;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_STEP_LT_STPTOL = (int)2;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_WARNING = (int)99;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_MEM_NULL = (int)-1;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ILL_INPUT = (int)-2;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_NO_MALLOC = (int)-3;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_MEM_FAIL = (int)-4;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LINESEARCH_NONCONV = (int)-5;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_MAXITER_REACHED = (int)-6;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_MXNEWT_5X_EXCEEDED = (int)-7;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LINESEARCH_BCFAIL = (int)-8;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LINSOLV_NO_RECOVERY = (int)-9;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LINIT_FAIL = (int)-10;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LSETUP_FAIL = (int)-11;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LSOLVE_FAIL = (int)-12;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_SYSFUNC_FAIL = (int)-13;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_FIRST_SYSFUNC_ERR = (int)-14;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_REPTD_SYSFUNC_ERR = (int)-15;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_VECTOROP_ERR = (int)-16;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_CONTEXT_ERR = (int)-17;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ORTH_MGS = (int)0;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ORTH_ICWY = (int)1;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ORTH_CGS2 = (int)2;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ORTH_DCGS2 = (int)3;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ETACHOICE1 = (int)1;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ETACHOICE2 = (int)2;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_ETACONSTANT = (int)3;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_NONE = (int)0;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_LINESEARCH = (int)1;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_PICARD = (int)2;
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public static final int KIN_FP = (int)3;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_SUCCESS = (int)0;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_MEM_NULL = (int)-1;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_LMEM_NULL = (int)-2;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_ILL_INPUT = (int)-3;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_MEM_FAIL = (int)-4;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_PMEM_NULL = (int)-5;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_JACFUNC_ERR = (int)-6;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_SUNMAT_FAIL = (int)-7;
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public static final int KINLS_SUNLS_FAIL = (int)-8;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_ATIMES_NULL = (int)-804;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_ATIMES_FAIL_UNREC = (int)-805;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_PSET_FAIL_UNREC = (int)-806;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_PSOLVE_NULL = (int)-807;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_PSOLVE_FAIL_UNREC = (int)-808;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_GS_FAIL = (int)-810;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_QRSOL_FAIL = (int)-811;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_RECOV_FAILURE = (int)800;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_RES_REDUCED = (int)801;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_CONV_FAIL = (int)802;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_ATIMES_FAIL_REC = (int)803;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_PSET_FAIL_REC = (int)804;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_PSOLVE_FAIL_REC = (int)805;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_PACKAGE_FAIL_REC = (int)806;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_QRFACT_FAIL = (int)807;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final int SUNLS_LUFACT_FAIL = (int)808;
	/** <i>native declaration : include\sundials\sundials_linearsolver.h</i> */
	public static final String SUNLS_MSG_RESIDUAL = (String)"\t\tlin. iteration %ld, lin. residual: %g\n";
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public interface KINSysFn extends Callback {
		int apply(N_Vector uu, N_Vector fval, Pointer user_data);
	};
	/** <i>native declaration : include\kinsol\kinsol.h</i> */
	public interface KINInfoHandlerFn extends Callback {
		void apply(Pointer module, Pointer function, Pointer msg, Pointer user_data);
	};
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public interface KINLsJacFn extends Callback {
		int apply(N_Vector u, N_Vector fu, SUNMatrix J, Pointer user_data, N_Vector tmp1, N_Vector tmp2);
	};
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public interface KINLsPrecSetupFn extends Callback {
		int apply(N_Vector uu, N_Vector uscale, N_Vector fval, N_Vector fscale, Pointer user_data);
	};
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public interface KINLsPrecSolveFn extends Callback {
		int apply(N_Vector uu, N_Vector uscale, N_Vector fval, N_Vector fscale, N_Vector vv, Pointer user_data);
	};
	/** <i>native declaration : include\kinsol\kinsol_ls.h</i> */
	public interface KINLsJacTimesVecFn extends Callback {
		int apply(N_Vector v, N_Vector Jv, N_Vector uu, IntByReference new_uu, Pointer J_data);
	};
	/** <i>native declaration : include\sundials\sundials_iterative.h</i> */
	public interface SUNATimesFn extends Callback {
		int apply(Pointer A_data, N_Vector v, N_Vector z);
	};
	/** <i>native declaration : include\sundials\sundials_iterative.h</i> */
	public interface SUNPSetupFn extends Callback {
		int apply(Pointer P_data);
	};
	/** <i>native declaration : include\sundials\sundials_iterative.h</i> */
	public interface SUNPSolveFn extends Callback {
		int apply(Pointer P_data, N_Vector r, N_Vector z, sunrealtype tol, int lr);
	};
	/** <i>native declaration : include\sundials\sundials_iterative.h</i> */
	public interface SUNQRAddFn extends Callback {
		int apply(N_Vector Q, sunrealtype R, N_Vector f, int m, int mMax, Pointer QR_data);
	};
	/**
	 * Creation function<br>
	 * Original signature : <code>void* KINCreate(SUNContext)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:70</i><br>
	 * @deprecated use the safer methods {@link #KINCreate(SUNContext)} and {@link #KINCreate(Pointer)} instead
	 */
	@Deprecated 
	Pointer KINCreate(Pointer sunctx);
	/**
	 * Creation function<br>
	 * Original signature : <code>void* KINCreate(SUNContext)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:70</i>
	 */
	Pointer KINCreate(SUNContext sunctx);
	/**
	 * Initialization function<br>
	 * Original signature : <code>int KINInit(void*, KINSysFn, N_Vector)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:73</i>
	 */
	int KINInit(Pointer kinmem, KINSysFn func, N_Vector tmpl);
	/**
	 * Solver function<br>
	 * Original signature : <code>int KINSol(void*, N_Vector, int, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:76</i>
	 */
	int KINSol(Pointer kinmem, N_Vector uu, int strategy, N_Vector u_scale, N_Vector f_scale);
	/**
	 * Optional input functions<br>
	 * Original signature : <code>int KINSetUserData(void*, void*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:80</i>
	 */
	int KINSetUserData(Pointer kinmem, Pointer user_data);
	/**
	 * Original signature : <code>int KINSetDamping(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:81</i>
	 */
	int KINSetDamping(Pointer kinmem, sunrealtype beta);
	/**
	 * Original signature : <code>int KINSetMAA(void*, long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:82</i>
	 */
	int KINSetMAA(Pointer kinmem, long maa);
	/**
	 * Original signature : <code>int KINSetOrthAA(void*, int)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:83</i>
	 */
	int KINSetOrthAA(Pointer kinmem, int orthaa);
	/**
	 * Original signature : <code>int KINSetDelayAA(void*, long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:84</i>
	 */
	int KINSetDelayAA(Pointer kinmem, long delay);
	/**
	 * Original signature : <code>int KINSetDampingAA(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:85</i>
	 */
	int KINSetDampingAA(Pointer kinmem, sunrealtype beta);
	/**
	 * Original signature : <code>int KINSetReturnNewest(void*, sunbooleantype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:86</i>
	 */
	int KINSetReturnNewest(Pointer kinmem, int ret_newest);
	/**
	 * Original signature : <code>int KINSetNumMaxIters(void*, long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:87</i>
	 */
	int KINSetNumMaxIters(Pointer kinmem, long mxiter);
	/**
	 * Original signature : <code>int KINSetNoInitSetup(void*, sunbooleantype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:88</i>
	 */
	int KINSetNoInitSetup(Pointer kinmem, int noInitSetup);
	/**
	 * Original signature : <code>int KINSetNoResMon(void*, sunbooleantype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:89</i>
	 */
	int KINSetNoResMon(Pointer kinmem, int noNNIResMon);
	/**
	 * Original signature : <code>int KINSetMaxSetupCalls(void*, long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:90</i>
	 */
	int KINSetMaxSetupCalls(Pointer kinmem, long msbset);
	/**
	 * Original signature : <code>int KINSetMaxSubSetupCalls(void*, long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:91</i>
	 */
	int KINSetMaxSubSetupCalls(Pointer kinmem, long msbsetsub);
	/**
	 * Original signature : <code>int KINSetEtaForm(void*, int)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:92</i>
	 */
	int KINSetEtaForm(Pointer kinmem, int etachoice);
	/**
	 * Original signature : <code>int KINSetEtaConstValue(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:93</i>
	 */
	int KINSetEtaConstValue(Pointer kinmem, sunrealtype eta);
	/**
	 * Original signature : <code>int KINSetEtaParams(void*, sunrealtype, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:94</i>
	 */
	int KINSetEtaParams(Pointer kinmem, sunrealtype egamma, sunrealtype ealpha);
	/**
	 * Original signature : <code>int KINSetResMonParams(void*, sunrealtype, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:96</i>
	 */
	int KINSetResMonParams(Pointer kinmem, sunrealtype omegamin, sunrealtype omegamax);
	/**
	 * Original signature : <code>int KINSetResMonConstValue(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:98</i>
	 */
	int KINSetResMonConstValue(Pointer kinmem, sunrealtype omegaconst);
	/**
	 * Original signature : <code>int KINSetNoMinEps(void*, sunbooleantype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:99</i>
	 */
	int KINSetNoMinEps(Pointer kinmem, int noMinEps);
	/**
	 * Original signature : <code>int KINSetMaxNewtonStep(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:100</i>
	 */
	int KINSetMaxNewtonStep(Pointer kinmem, sunrealtype mxnewtstep);
	/**
	 * Original signature : <code>int KINSetMaxBetaFails(void*, long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:101</i>
	 */
	int KINSetMaxBetaFails(Pointer kinmem, long mxnbcf);
	/**
	 * Original signature : <code>int KINSetRelErrFunc(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:102</i>
	 */
	int KINSetRelErrFunc(Pointer kinmem, sunrealtype relfunc);
	/**
	 * Original signature : <code>int KINSetFuncNormTol(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:103</i>
	 */
	int KINSetFuncNormTol(Pointer kinmem, sunrealtype fnormtol);
	/**
	 * Original signature : <code>int KINSetScaledStepTol(void*, sunrealtype)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:104</i>
	 */
	int KINSetScaledStepTol(Pointer kinmem, sunrealtype scsteptol);
	/**
	 * Original signature : <code>int KINSetConstraints(void*, N_Vector)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:105</i>
	 */
	int KINSetConstraints(Pointer kinmem, N_Vector constraints);
	/**
	 * Original signature : <code>int KINSetSysFunc(void*, KINSysFn)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:106</i>
	 */
	int KINSetSysFunc(Pointer kinmem, KINSysFn func);
	/**
	 * Optional output functions<br>
	 * Original signature : <code>int KINGetWorkSpace(void*, long long*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:109</i><br>
	 * @deprecated use the safer methods {@link #KINGetWorkSpace(Pointer, LongBuffer, LongBuffer)} and {@link #KINGetWorkSpace(Pointer, LongByReference, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetWorkSpace(Pointer kinmem, LongByReference lenrw, LongByReference leniw);
	/**
	 * Optional output functions<br>
	 * Original signature : <code>int KINGetWorkSpace(void*, long long*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:109</i>
	 */
	int KINGetWorkSpace(Pointer kinmem, LongBuffer lenrw, LongBuffer leniw);
	/**
	 * Original signature : <code>int KINGetNumNonlinSolvIters(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:111</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumNonlinSolvIters(Pointer, LongBuffer)} and {@link #KINGetNumNonlinSolvIters(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumNonlinSolvIters(Pointer kinmem, LongByReference nniters);
	/**
	 * Original signature : <code>int KINGetNumNonlinSolvIters(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:111</i>
	 */
	int KINGetNumNonlinSolvIters(Pointer kinmem, LongBuffer nniters);
	/**
	 * Original signature : <code>int KINGetNumFuncEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:112</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumFuncEvals(Pointer, LongBuffer)} and {@link #KINGetNumFuncEvals(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumFuncEvals(Pointer kinmem, LongByReference nfevals);
	/**
	 * Original signature : <code>int KINGetNumFuncEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:112</i>
	 */
	int KINGetNumFuncEvals(Pointer kinmem, LongBuffer nfevals);
	/**
	 * Original signature : <code>int KINGetNumBetaCondFails(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:113</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumBetaCondFails(Pointer, LongBuffer)} and {@link #KINGetNumBetaCondFails(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumBetaCondFails(Pointer kinmem, LongByReference nbcfails);
	/**
	 * Original signature : <code>int KINGetNumBetaCondFails(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:113</i>
	 */
	int KINGetNumBetaCondFails(Pointer kinmem, LongBuffer nbcfails);
	/**
	 * Original signature : <code>int KINGetNumBacktrackOps(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:114</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumBacktrackOps(Pointer, LongBuffer)} and {@link #KINGetNumBacktrackOps(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumBacktrackOps(Pointer kinmem, LongByReference nbacktr);
	/**
	 * Original signature : <code>int KINGetNumBacktrackOps(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:114</i>
	 */
	int KINGetNumBacktrackOps(Pointer kinmem, LongBuffer nbacktr);
	/**
	 * Original signature : <code>int KINGetFuncNorm(void*, sunrealtype*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:115</i>
	 */
	int KINGetFuncNorm(Pointer kinmem, sunrealtype fnorm);
	/**
	 * Original signature : <code>int KINGetStepLength(void*, sunrealtype*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:116</i>
	 */
	int KINGetStepLength(Pointer kinmem, sunrealtype steplength);
	/**
	 * Original signature : <code>int KINGetUserData(void*, void**)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:117</i>
	 */
	int KINGetUserData(Pointer kinmem, PointerByReference user_data);
	/**
	 * Original signature : <code>int KINPrintAllStats(void*, FILE*, SUNOutputFormat)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:118</i>
	 */
	int KINPrintAllStats(Pointer kinmem, FILE outfile, int fmt);
	/**
	 * Original signature : <code>char* KINGetReturnFlagName(long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:120</i>
	 */
	Pointer KINGetReturnFlagName(long flag);
	/**
	 * Free function<br>
	 * Original signature : <code>void KINFree(void**)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:123</i>
	 */
	void KINFree(PointerByReference kinmem);
	/**
	 * KINLS interface function that depends on KINSysFn<br>
	 * Original signature : <code>int KINSetJacTimesVecSysFn(void*, KINSysFn)</code><br>
	 * <i>native declaration : include\kinsol\kinsol.h:126</i>
	 */
	int KINSetJacTimesVecSysFn(Pointer kinmem, KINSysFn jtimesSysFn);
	/**
	 * ==================================================================<br>
	 * KINLS Exported functions<br>
	 * ==================================================================<br>
	 * Original signature : <code>int KINSetLinearSolver(void*, SUNLinearSolver, SUNMatrix)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:41</i>
	 */
	int KINSetLinearSolver(Pointer kinmem, SUNLinearSolver LS, SUNMatrix A);
	/**
	 * -----------------------------------------------------------------<br>
	 * Optional inputs to the KINLS linear solver interface<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int KINSetJacFn(void*, KINLsJacFn)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:48</i>
	 */
	int KINSetJacFn(Pointer kinmem, KINLsJacFn jac);
	/**
	 * Original signature : <code>int KINSetPreconditioner(void*, KINLsPrecSetupFn, KINLsPrecSolveFn)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:49</i>
	 */
	int KINSetPreconditioner(Pointer kinmem, KINLsPrecSetupFn psetup, KINLsPrecSolveFn psolve);
	/**
	 * Original signature : <code>int KINSetJacTimesVecFn(void*, KINLsJacTimesVecFn)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:51</i>
	 */
	int KINSetJacTimesVecFn(Pointer kinmem, KINLsJacTimesVecFn jtv);
	/**
	 * -----------------------------------------------------------------<br>
	 * Optional outputs from the KINLS linear solver interface<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int KINGetJac(void*, SUNMatrix*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:57</i>
	 */
	int KINGetJac(Pointer kinmem, SUNMatrix J);
	/**
	 * Original signature : <code>int KINGetJacNumIters(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:58</i><br>
	 * @deprecated use the safer methods {@link #KINGetJacNumIters(Pointer, LongBuffer)} and {@link #KINGetJacNumIters(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetJacNumIters(Pointer kinmem, LongByReference nni_J);
	/**
	 * Original signature : <code>int KINGetJacNumIters(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:58</i>
	 */
	int KINGetJacNumIters(Pointer kinmem, LongBuffer nni_J);
	/**
	 * Original signature : <code>int KINGetLinWorkSpace(void*, long long*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:59</i><br>
	 * @deprecated use the safer methods {@link #KINGetLinWorkSpace(Pointer, LongBuffer, LongBuffer)} and {@link #KINGetLinWorkSpace(Pointer, LongByReference, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetLinWorkSpace(Pointer kinmem, LongByReference lenrwLS, LongByReference leniwLS);
	/**
	 * Original signature : <code>int KINGetLinWorkSpace(void*, long long*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:59</i>
	 */
	int KINGetLinWorkSpace(Pointer kinmem, LongBuffer lenrwLS, LongBuffer leniwLS);
	/**
	 * Original signature : <code>int KINGetNumJacEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:61</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumJacEvals(Pointer, LongBuffer)} and {@link #KINGetNumJacEvals(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumJacEvals(Pointer kinmem, LongByReference njevals);
	/**
	 * Original signature : <code>int KINGetNumJacEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:61</i>
	 */
	int KINGetNumJacEvals(Pointer kinmem, LongBuffer njevals);
	/**
	 * Original signature : <code>int KINGetNumLinFuncEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:62</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumLinFuncEvals(Pointer, LongBuffer)} and {@link #KINGetNumLinFuncEvals(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumLinFuncEvals(Pointer kinmem, LongByReference nfevals);
	/**
	 * Original signature : <code>int KINGetNumLinFuncEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:62</i>
	 */
	int KINGetNumLinFuncEvals(Pointer kinmem, LongBuffer nfevals);
	/**
	 * Original signature : <code>int KINGetNumPrecEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:63</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumPrecEvals(Pointer, LongBuffer)} and {@link #KINGetNumPrecEvals(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumPrecEvals(Pointer kinmem, LongByReference npevals);
	/**
	 * Original signature : <code>int KINGetNumPrecEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:63</i>
	 */
	int KINGetNumPrecEvals(Pointer kinmem, LongBuffer npevals);
	/**
	 * Original signature : <code>int KINGetNumPrecSolves(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:64</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumPrecSolves(Pointer, LongBuffer)} and {@link #KINGetNumPrecSolves(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumPrecSolves(Pointer kinmem, LongByReference npsolves);
	/**
	 * Original signature : <code>int KINGetNumPrecSolves(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:64</i>
	 */
	int KINGetNumPrecSolves(Pointer kinmem, LongBuffer npsolves);
	/**
	 * Original signature : <code>int KINGetNumLinIters(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:65</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumLinIters(Pointer, LongBuffer)} and {@link #KINGetNumLinIters(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumLinIters(Pointer kinmem, LongByReference nliters);
	/**
	 * Original signature : <code>int KINGetNumLinIters(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:65</i>
	 */
	int KINGetNumLinIters(Pointer kinmem, LongBuffer nliters);
	/**
	 * Original signature : <code>int KINGetNumLinConvFails(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:66</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumLinConvFails(Pointer, LongBuffer)} and {@link #KINGetNumLinConvFails(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumLinConvFails(Pointer kinmem, LongByReference nlcfails);
	/**
	 * Original signature : <code>int KINGetNumLinConvFails(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:66</i>
	 */
	int KINGetNumLinConvFails(Pointer kinmem, LongBuffer nlcfails);
	/**
	 * Original signature : <code>int KINGetNumJtimesEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:67</i><br>
	 * @deprecated use the safer methods {@link #KINGetNumJtimesEvals(Pointer, LongBuffer)} and {@link #KINGetNumJtimesEvals(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetNumJtimesEvals(Pointer kinmem, LongByReference njvevals);
	/**
	 * Original signature : <code>int KINGetNumJtimesEvals(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:67</i>
	 */
	int KINGetNumJtimesEvals(Pointer kinmem, LongBuffer njvevals);
	/**
	 * Original signature : <code>int KINGetLastLinFlag(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:68</i><br>
	 * @deprecated use the safer methods {@link #KINGetLastLinFlag(Pointer, LongBuffer)} and {@link #KINGetLastLinFlag(Pointer, LongByReference)} instead
	 */
	@Deprecated 
	int KINGetLastLinFlag(Pointer kinmem, LongByReference flag);
	/**
	 * Original signature : <code>int KINGetLastLinFlag(void*, long long*)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:68</i>
	 */
	int KINGetLastLinFlag(Pointer kinmem, LongBuffer flag);
	/**
	 * Original signature : <code>char* KINGetLinReturnFlagName(long long)</code><br>
	 * <i>native declaration : include\kinsol\kinsol_ls.h:69</i>
	 */
	Pointer KINGetLinReturnFlagName(long flag);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNModifiedGS<br>
	 * -----------------------------------------------------------------<br>
	 * SUNModifiedGS performs a modified Gram-Schmidt orthogonalization<br>
	 * of the N_Vector v[k] against the p unit N_Vectors at<br>
	 * v[k-1], v[k-2], ..., v[k-p].<br>
	 * v is an array of (k+1) N_Vectors v[i], i=0, 1, ..., k.<br>
	 * v[k-1], v[k-2], ..., v[k-p] are assumed to have L2-norm<br>
	 * equal to 1.<br>
	 * h is the output k by k Hessenberg matrix of inner products.<br>
	 * This matrix must be allocated row-wise so that the (i,j)th<br>
	 * entry is h[i][j]. The inner products (v[i],v[k]),<br>
	 * i=i0, i0+1, ..., k-1, are stored at h[i][k-1]. Here<br>
	 * i0=SUNMAX(0,k-p).<br>
	 * k is the index of the vector in the v array that needs to be<br>
	 * orthogonalized against previous vectors in the v array.<br>
	 * p is the number of previous vectors in the v array against<br>
	 * which v[k] is to be orthogonalized.<br>
	 * new_vk_norm is a pointer to memory allocated by the caller to<br>
	 * hold the Euclidean norm of the orthogonalized vector v[k].<br>
	 * If (k-p) < 0, then SUNModifiedGS uses p=k. The orthogonalized<br>
	 * v[k] is NOT normalized and is stored over the old v[k]. Once<br>
	 * the orthogonalization has been performed, the Euclidean norm<br>
	 * of v[k] is stored in (*new_vk_norm).<br>
	 * SUNModifiedGS returns 0 to indicate success. It cannot fail.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNModifiedGS(N_Vector*, sunrealtype**, int, int, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:172</i><br>
	 * @deprecated use the safer method {@link #SUNModifiedGS(N_Vector, sunrealtype[], int, int, sunrealtype)} instead
	 */
	@Deprecated 
	int SUNModifiedGS(N_Vector v, PointerByReference h, int k, int p, sunrealtype new_vk_norm);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNModifiedGS<br>
	 * -----------------------------------------------------------------<br>
	 * SUNModifiedGS performs a modified Gram-Schmidt orthogonalization<br>
	 * of the N_Vector v[k] against the p unit N_Vectors at<br>
	 * v[k-1], v[k-2], ..., v[k-p].<br>
	 * v is an array of (k+1) N_Vectors v[i], i=0, 1, ..., k.<br>
	 * v[k-1], v[k-2], ..., v[k-p] are assumed to have L2-norm<br>
	 * equal to 1.<br>
	 * h is the output k by k Hessenberg matrix of inner products.<br>
	 * This matrix must be allocated row-wise so that the (i,j)th<br>
	 * entry is h[i][j]. The inner products (v[i],v[k]),<br>
	 * i=i0, i0+1, ..., k-1, are stored at h[i][k-1]. Here<br>
	 * i0=SUNMAX(0,k-p).<br>
	 * k is the index of the vector in the v array that needs to be<br>
	 * orthogonalized against previous vectors in the v array.<br>
	 * p is the number of previous vectors in the v array against<br>
	 * which v[k] is to be orthogonalized.<br>
	 * new_vk_norm is a pointer to memory allocated by the caller to<br>
	 * hold the Euclidean norm of the orthogonalized vector v[k].<br>
	 * If (k-p) < 0, then SUNModifiedGS uses p=k. The orthogonalized<br>
	 * v[k] is NOT normalized and is stored over the old v[k]. Once<br>
	 * the orthogonalization has been performed, the Euclidean norm<br>
	 * of v[k] is stored in (*new_vk_norm).<br>
	 * SUNModifiedGS returns 0 to indicate success. It cannot fail.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNModifiedGS(N_Vector*, sunrealtype**, int, int, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:172</i>
	 */
	int SUNModifiedGS(N_Vector v, sunrealtype h[], int k, int p, sunrealtype new_vk_norm);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNClassicalGS<br>
	 * -----------------------------------------------------------------<br>
	 * SUNClassicalGS performs a classical Gram-Schmidt<br>
	 * orthogonalization of the N_Vector v[k] against the p unit<br>
	 * N_Vectors at v[k-1], v[k-2], ..., v[k-p]. The parameters v, h,<br>
	 * k, p, and new_vk_norm are as described in the documentation<br>
	 * for SUNModifiedGS.<br>
	 * stemp is a length k+1 array of sunrealtype which can be used as<br>
	 * workspace by the SUNClassicalGS routine.<br>
	 * vtemp is an N_Vector array of k+1 vectors which can be used as<br>
	 * workspace by the SUNClassicalGS routine.<br>
	 * SUNClassicalGS returns 0 to indicate success.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNClassicalGS(N_Vector*, sunrealtype**, int, int, sunrealtype*, sunrealtype*, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:196</i><br>
	 * @deprecated use the safer method {@link #SUNClassicalGS(N_Vector, sunrealtype[], int, int, sunrealtype, sunrealtype, N_Vector)} instead
	 */
	@Deprecated 
	int SUNClassicalGS(N_Vector v, PointerByReference h, int k, int p, sunrealtype new_vk_norm, sunrealtype stemp, N_Vector vtemp);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNClassicalGS<br>
	 * -----------------------------------------------------------------<br>
	 * SUNClassicalGS performs a classical Gram-Schmidt<br>
	 * orthogonalization of the N_Vector v[k] against the p unit<br>
	 * N_Vectors at v[k-1], v[k-2], ..., v[k-p]. The parameters v, h,<br>
	 * k, p, and new_vk_norm are as described in the documentation<br>
	 * for SUNModifiedGS.<br>
	 * stemp is a length k+1 array of sunrealtype which can be used as<br>
	 * workspace by the SUNClassicalGS routine.<br>
	 * vtemp is an N_Vector array of k+1 vectors which can be used as<br>
	 * workspace by the SUNClassicalGS routine.<br>
	 * SUNClassicalGS returns 0 to indicate success.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNClassicalGS(N_Vector*, sunrealtype**, int, int, sunrealtype*, sunrealtype*, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:196</i>
	 */
	int SUNClassicalGS(N_Vector v, sunrealtype h[], int k, int p, sunrealtype new_vk_norm, sunrealtype stemp, N_Vector vtemp);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRfact<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRfact performs a QR factorization of the Hessenberg matrix H.<br>
	 * n is the problem size; the matrix H is (n+1) by n.<br>
	 * h is the (n+1) by n Hessenberg matrix H to be factored. It is<br>
	 * stored row-wise.<br>
	 * q is an array of length 2*n containing the Givens rotations<br>
	 * computed by this function. A Givens rotation has the form:<br>
	 * | c  -s |<br>
	 * | s   c |.<br>
	 * The components of the Givens rotations are stored in q as<br>
	 * (c, s, c, s, ..., c, s).<br>
	 * job is a control flag. If job==0, then a new QR factorization<br>
	 * is performed. If job!=0, then it is assumed that the first<br>
	 * n-1 columns of h have already been factored and only the last<br>
	 * column needs to be updated.<br>
	 * SUNQRfact returns 0 if successful. If a zero is encountered on<br>
	 * the diagonal of the triangular factor R, then SUNQRfact returns<br>
	 * the equation number of the zero entry, where the equations are<br>
	 * numbered from 1, not 0. If SUNQRsol is subsequently called in<br>
	 * this situation, it will return an error because it could not<br>
	 * divide by the zero diagonal entry.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int SUNQRfact(int, sunrealtype**, sunrealtype*, int)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:233</i><br>
	 * @deprecated use the safer method {@link #SUNQRfact(int, sunrealtype[], sunrealtype, int)} instead
	 */
	@Deprecated 
	int SUNQRfact(int n, PointerByReference h, sunrealtype q, int job);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRfact<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRfact performs a QR factorization of the Hessenberg matrix H.<br>
	 * n is the problem size; the matrix H is (n+1) by n.<br>
	 * h is the (n+1) by n Hessenberg matrix H to be factored. It is<br>
	 * stored row-wise.<br>
	 * q is an array of length 2*n containing the Givens rotations<br>
	 * computed by this function. A Givens rotation has the form:<br>
	 * | c  -s |<br>
	 * | s   c |.<br>
	 * The components of the Givens rotations are stored in q as<br>
	 * (c, s, c, s, ..., c, s).<br>
	 * job is a control flag. If job==0, then a new QR factorization<br>
	 * is performed. If job!=0, then it is assumed that the first<br>
	 * n-1 columns of h have already been factored and only the last<br>
	 * column needs to be updated.<br>
	 * SUNQRfact returns 0 if successful. If a zero is encountered on<br>
	 * the diagonal of the triangular factor R, then SUNQRfact returns<br>
	 * the equation number of the zero entry, where the equations are<br>
	 * numbered from 1, not 0. If SUNQRsol is subsequently called in<br>
	 * this situation, it will return an error because it could not<br>
	 * divide by the zero diagonal entry.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int SUNQRfact(int, sunrealtype**, sunrealtype*, int)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:233</i>
	 */
	int SUNQRfact(int n, sunrealtype h[], sunrealtype q, int job);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRsol<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRsol solves the linear least squares problem<br>
	 * min (b - H*x, b - H*x), x in R^n,<br>
	 * where H is a Hessenberg matrix, and b is in R^(n+1).<br>
	 * It uses the QR factors of H computed by SUNQRfact.<br>
	 * n is the problem size; the matrix H is (n+1) by n.<br>
	 * h is a matrix (computed by SUNQRfact) containing the upper<br>
	 * triangular factor R of the original Hessenberg matrix H.<br>
	 * q is an array of length 2*n (computed by SUNQRfact) containing<br>
	 * the Givens rotations used to factor H.<br>
	 * b is the (n+1)-vector appearing in the least squares problem<br>
	 * above.<br>
	 * On return, b contains the solution x of the least squares<br>
	 * problem, if SUNQRsol was successful.<br>
	 * SUNQRsol returns a 0 if successful.  Otherwise, a zero was<br>
	 * encountered on the diagonal of the triangular factor R.<br>
	 * In this case, SUNQRsol returns the equation number (numbered<br>
	 * from 1, not 0) of the zero entry.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int SUNQRsol(int, sunrealtype**, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:268</i><br>
	 * @deprecated use the safer method {@link #SUNQRsol(int, sunrealtype[], sunrealtype, sunrealtype)} instead
	 */
	@Deprecated 
	int SUNQRsol(int n, PointerByReference h, sunrealtype q, sunrealtype b);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRsol<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRsol solves the linear least squares problem<br>
	 * min (b - H*x, b - H*x), x in R^n,<br>
	 * where H is a Hessenberg matrix, and b is in R^(n+1).<br>
	 * It uses the QR factors of H computed by SUNQRfact.<br>
	 * n is the problem size; the matrix H is (n+1) by n.<br>
	 * h is a matrix (computed by SUNQRfact) containing the upper<br>
	 * triangular factor R of the original Hessenberg matrix H.<br>
	 * q is an array of length 2*n (computed by SUNQRfact) containing<br>
	 * the Givens rotations used to factor H.<br>
	 * b is the (n+1)-vector appearing in the least squares problem<br>
	 * above.<br>
	 * On return, b contains the solution x of the least squares<br>
	 * problem, if SUNQRsol was successful.<br>
	 * SUNQRsol returns a 0 if successful.  Otherwise, a zero was<br>
	 * encountered on the diagonal of the triangular factor R.<br>
	 * In this case, SUNQRsol returns the equation number (numbered<br>
	 * from 1, not 0) of the zero entry.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int SUNQRsol(int, sunrealtype**, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:268</i>
	 */
	int SUNQRsol(int n, sunrealtype h[], sunrealtype q, sunrealtype b);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRAdd_MGS<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRAdd_MGS uses Modified Gram Schmidt to update the QR factorization<br>
	 * stored in user inputs<br>
	 *   - N_Vector *Q<br>
	 *   - sunrealtype *R<br>
	 * to include the orthonormalized vector input by<br>
	 *   - N_Vector df.<br>
	 * Additional input parameters include:<br>
	 *      m : (int) current number of vectors in QR factorization<br>
	 *   mMax : (int) maximum number of vectors that will be in the QR<br>
	 *          factorization (the allocated number of N_Vectors in Q)<br>
	 * QRdata : (void *) a struct containing any additional temporary<br>
	 *          vectors or arrays required for the QRAdd routine<br>
	 * On return, Q and R contain the updated Q R factors, if<br>
	 * SUNQRAdd_MGS was successful.<br>
	 * SUNQRAdd_MGS returns a 0 if successful.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNQRAdd_MGS(N_Vector*, sunrealtype*, N_Vector, int, int, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:299</i>
	 */
	int SUNQRAdd_MGS(N_Vector Q, sunrealtype R, N_Vector df, int m, int mMax, Pointer QRdata);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRAdd_ICWY<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRAdd_ICWY uses the Inverse Compact WY Modified Gram Schmidt<br>
	 * method to update the QR factorization stored in user inputs<br>
	 *   - N_Vector *Q<br>
	 *   - sunrealtype *R<br>
	 *   - sunrealtype *T (held within (void *) QRdata)<br>
	 * to include the orthonormalized vector input by<br>
	 *   - N_Vector df.<br>
	 * where the factorization to be updated is of the form<br>
	 *   Q * T * R<br>
	 * Additional input parameters include:<br>
	 *     m :  (int) current number of vectors in QR factorization<br>
	 *  mMax : (int) maximum number of vectors that will be in the QR<br>
	 *         factorization (the allocated number of N_Vectors in Q)<br>
	 * QRdata : (void *) a struct containing any additional temporary<br>
	 *          vectors or arrays required for the QRAdd routine<br>
	 * QRdata should contain :<br>
	 *        N_Vector vtemp, sunrealtype *temp_array (this will be used for T)<br>
	 * On return, Q, R, and T contain the updated Q T R factors, if<br>
	 * SUNQRAdd_ICWY was successful.<br>
	 * SUNQRAdd_ICWY returns a 0 if successful.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNQRAdd_ICWY(N_Vector*, sunrealtype*, N_Vector, int, int, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:337</i>
	 */
	int SUNQRAdd_ICWY(N_Vector Q, sunrealtype R, N_Vector df, int m, int mMax, Pointer QRdata);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRAdd_ICWY_SB<br>
	 * -----------------------------------------------------------------<br>
	 *  The same function as SUNQRAdd_ICWY but using a single buffer<br>
	 *  for global reductions.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNQRAdd_ICWY_SB(N_Vector*, sunrealtype*, N_Vector, int, int, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:350</i>
	 */
	int SUNQRAdd_ICWY_SB(N_Vector Q, sunrealtype R, N_Vector df, int m, int mMax, Pointer QRdata);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRAdd_CGS2<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRAdd_CGS2 uses a Classical Gram Schmidt with Reorthogonalization<br>
	 * formulation to update the QR factorization stored in user inputs<br>
	 *   - N_Vector *Q<br>
	 *   - sunrealtype *R<br>
	 * to include the orthonormalized vector input by<br>
	 *   - N_Vector df.<br>
	 * Additional input parameters include:<br>
	 *      m : (int) current number of vectors in QR factorization<br>
	 *   mMax : (int) maximum number of vectors that will be in the QR<br>
	 *          factorization (the allocated number of N_Vectors in Q)<br>
	 * QRdata : (void *) a struct containing any additional temporary<br>
	 *          vectors or arrays required for the QRAdd routine<br>
	 * QRdata should contain :<br>
	 *        N_Vector vtemp, N_Vector vtemp2, sunrealtype *temp_array<br>
	 * On return, Q and R contain the updated Q R factors, if<br>
	 * SUNQRAdd_CGS2 was successful.<br>
	 * SUNQRAdd_CGS2 returns a 0 if successful.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNQRAdd_CGS2(N_Vector*, sunrealtype*, N_Vector, int, int, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:385</i>
	 */
	int SUNQRAdd_CGS2(N_Vector Q, sunrealtype R, N_Vector df, int m, int mMax, Pointer QRdata);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRAdd_DCGS2<br>
	 * -----------------------------------------------------------------<br>
	 * SUNQRAdd_DCGS2 uses a Classical Gram Schmidt with Reorthogonalization<br>
	 * formulation that delays reorthogonlization (for the purpose of<br>
	 * reducing number of inner products) to update the QR factorization<br>
	 * stored in user inputs<br>
	 *   - N_Vector *Q<br>
	 *   - sunrealtype *R<br>
	 * to include the orthonormalized vector input by<br>
	 *   - N_Vector df.<br>
	 * Additional input parameters include:<br>
	 *      m : (int) current number of vectors in QR factorization<br>
	 *   mMax : (int) maximum number of vectors that will be in the QR<br>
	 *          factorization (the allocated number of N_Vectors in Q)<br>
	 * QRdata : (void *) a struct containing any additional temporary<br>
	 *          vectors or arrays required for the QRAdd routine<br>
	 * QRdata should contain :<br>
	 *        N_Vector vtemp, N_Vector vtemp2, sunrealtype *temp_array<br>
	 * On return, Q and R contain the updated Q R factors, if<br>
	 * SUNQRAdd_DCGS2 was successful.<br>
	 * SUNQRAdd_DCGS2 returns a 0 if successful. Otherwise,....<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNQRAdd_DCGS2(N_Vector*, sunrealtype*, N_Vector, int, int, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:422</i>
	 */
	int SUNQRAdd_DCGS2(N_Vector Q, sunrealtype R, N_Vector df, int m, int mMax, Pointer QRdata);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNQRAdd_DCGS2_SB<br>
	 * -----------------------------------------------------------------<br>
	 *  The same function as SUNQRAdd_DCGS2 but using a single buffer<br>
	 *  for global reductions.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNErrCode SUNQRAdd_DCGS2_SB(N_Vector*, sunrealtype*, N_Vector, int, int, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_iterative.h:435</i>
	 */
	int SUNQRAdd_DCGS2_SB(N_Vector Q, sunrealtype R, N_Vector df, int m, int mMax, Pointer QRdata);
	/**
	 * -----------------------------------------------------------------<br>
	 * Functions exported by SUNLinearSolver module<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNLinearSolver SUNLinSolNewEmpty(SUNContext)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:86</i><br>
	 * @deprecated use the safer methods {@link #SUNLinSolNewEmpty(SUNContext)} and {@link #SUNLinSolNewEmpty(Pointer)} instead
	 */
	@Deprecated 
	SUNLinearSolver SUNLinSolNewEmpty(Pointer sunctx);
	/**
	 * -----------------------------------------------------------------<br>
	 * Functions exported by SUNLinearSolver module<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNLinearSolver SUNLinSolNewEmpty(SUNContext)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:86</i>
	 */
	SUNLinearSolver SUNLinSolNewEmpty(SUNContext sunctx);
	/**
	 * Original signature : <code>void SUNLinSolFreeEmpty(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:89</i>
	 */
	void SUNLinSolFreeEmpty(SUNLinearSolver S);
	/**
	 * Original signature : <code>SUNLinearSolver_Type SUNLinSolGetType(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:92</i>
	 */
	int SUNLinSolGetType(SUNLinearSolver S);
	/**
	 * Original signature : <code>SUNLinearSolver_ID SUNLinSolGetID(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:95</i>
	 */
	int SUNLinSolGetID(SUNLinearSolver S);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolSetATimes(SUNLinearSolver, void*, SUNATimesFn)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:98</i>
	 */
	int SUNLinSolSetATimes(SUNLinearSolver S, Pointer A_data, SUNATimesFn ATimes);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolSetPreconditioner(SUNLinearSolver, void*, SUNPSetupFn, SUNPSolveFn)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:102</i>
	 */
	int SUNLinSolSetPreconditioner(SUNLinearSolver S, Pointer P_data, SUNPSetupFn Pset, SUNPSolveFn Psol);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolSetScalingVectors(SUNLinearSolver, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:106</i>
	 */
	int SUNLinSolSetScalingVectors(SUNLinearSolver S, N_Vector s1, N_Vector s2);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolSetZeroGuess(SUNLinearSolver, sunbooleantype)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:110</i>
	 */
	int SUNLinSolSetZeroGuess(SUNLinearSolver S, int onoff);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolInitialize(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:113</i>
	 */
	int SUNLinSolInitialize(SUNLinearSolver S);
	/**
	 * Original signature : <code>int SUNLinSolSetup(SUNLinearSolver, SUNMatrix)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:116</i>
	 */
	int SUNLinSolSetup(SUNLinearSolver S, SUNMatrix A);
	/**
	 * Original signature : <code>int SUNLinSolSolve(SUNLinearSolver, SUNMatrix, N_Vector, N_Vector, sunrealtype)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:119</i>
	 */
	int SUNLinSolSolve(SUNLinearSolver S, SUNMatrix A, N_Vector x, N_Vector b, sunrealtype tol);
	/**
	 * TODO(CJB): We should consider changing the return type to long int since<br>
	 * batched solvers could in theory return a very large number here.<br>
	 * Original signature : <code>int SUNLinSolNumIters(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:125</i>
	 */
	int SUNLinSolNumIters(SUNLinearSolver S);
	/**
	 * Original signature : <code>sunrealtype SUNLinSolResNorm(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:128</i>
	 */
	sunrealtype SUNLinSolResNorm(SUNLinearSolver S);
	/**
	 * Original signature : <code>N_Vector SUNLinSolResid(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:131</i>
	 */
	N_Vector SUNLinSolResid(SUNLinearSolver S);
	/**
	 * TODO(CJB): sunindextype being the return type here could cause a problem if<br>
	 * sunindextype happened to be smaller than an int.<br>
	 * Original signature : <code>sunindextype SUNLinSolLastFlag(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:136</i>
	 */
	sunindextype SUNLinSolLastFlag(SUNLinearSolver S);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolSpace(SUNLinearSolver, long long*, long long*)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:139</i><br>
	 * @deprecated use the safer methods {@link #SUNLinSolSpace(SUNLinearSolver, LongBuffer, LongBuffer)} and {@link #SUNLinSolSpace(SUNLinearSolver, LongByReference, LongByReference)} instead
	 */
	@Deprecated 
	int SUNLinSolSpace(SUNLinearSolver S, LongByReference lenrwLS, LongByReference leniwLS);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolSpace(SUNLinearSolver, long long*, long long*)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:139</i>
	 */
	int SUNLinSolSpace(SUNLinearSolver S, LongBuffer lenrwLS, LongBuffer leniwLS);
	/**
	 * Original signature : <code>SUNErrCode SUNLinSolFree(SUNLinearSolver)</code><br>
	 * <i>native declaration : include\sundials\sundials_linearsolver.h:143</i>
	 */
	int SUNLinSolFree(SUNLinearSolver S);
	public static class SUNLinearSolver_Ops extends PointerType {
		public SUNLinearSolver_Ops(Pointer address) {
			super(address);
		}
		public SUNLinearSolver_Ops() {
			super();
		}
	};
	public static class SUNLinearSolver extends PointerType {
		public SUNLinearSolver(Pointer address) {
			super(address);
		}
		public SUNLinearSolver() {
			super();
		}
	};
}
