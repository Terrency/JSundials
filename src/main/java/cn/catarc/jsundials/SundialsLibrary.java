package cn.catarc.jsundials;

import cn.catarc.jsundials.SundialsSunmatrixdenseLibrary.*;
import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
/**
 * JNA Wrapper for library <b>Sundials</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface SundialsLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "Sundials";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(SundialsLibrary.JNA_LIBRARY_NAME);
	public static final SundialsLibrary INSTANCE = (SundialsLibrary)Native.loadLibrary(SundialsLibrary.JNA_LIBRARY_NAME, SundialsLibrary.class);
	/**
	 * <i>native declaration : include\sundials\sundials_nvector.h</i><br>
	 * enum values
	 */
	public static interface N_Vector_ID {
		/** <i>native declaration : include\sundials\sundials_nvector.h:12</i> */
		public static final int SUNDIALS_NVEC_SERIAL = 0;
		/** <i>native declaration : include\sundials\sundials_nvector.h:13</i> */
		public static final int SUNDIALS_NVEC_PARALLEL = 1;
		/** <i>native declaration : include\sundials\sundials_nvector.h:14</i> */
		public static final int SUNDIALS_NVEC_OPENMP = 2;
		/** <i>native declaration : include\sundials\sundials_nvector.h:15</i> */
		public static final int SUNDIALS_NVEC_PTHREADS = 3;
		/** <i>native declaration : include\sundials\sundials_nvector.h:16</i> */
		public static final int SUNDIALS_NVEC_PARHYP = 4;
		/** <i>native declaration : include\sundials\sundials_nvector.h:17</i> */
		public static final int SUNDIALS_NVEC_PETSC = 5;
		/** <i>native declaration : include\sundials\sundials_nvector.h:18</i> */
		public static final int SUNDIALS_NVEC_CUDA = 6;
		/** <i>native declaration : include\sundials\sundials_nvector.h:19</i> */
		public static final int SUNDIALS_NVEC_HIP = 7;
		/** <i>native declaration : include\sundials\sundials_nvector.h:20</i> */
		public static final int SUNDIALS_NVEC_SYCL = 8;
		/** <i>native declaration : include\sundials\sundials_nvector.h:21</i> */
		public static final int SUNDIALS_NVEC_RAJA = 9;
		/** <i>native declaration : include\sundials\sundials_nvector.h:22</i> */
		public static final int SUNDIALS_NVEC_KOKKOS = 10;
		/** <i>native declaration : include\sundials\sundials_nvector.h:23</i> */
		public static final int SUNDIALS_NVEC_OPENMPDEV = 11;
		/** <i>native declaration : include\sundials\sundials_nvector.h:24</i> */
		public static final int SUNDIALS_NVEC_TRILINOS = 12;
		/** <i>native declaration : include\sundials\sundials_nvector.h:25</i> */
		public static final int SUNDIALS_NVEC_MANYVECTOR = 13;
		/** <i>native declaration : include\sundials\sundials_nvector.h:26</i> */
		public static final int SUNDIALS_NVEC_MPIMANYVECTOR = 14;
		/** <i>native declaration : include\sundials\sundials_nvector.h:27</i> */
		public static final int SUNDIALS_NVEC_MPIPLUSX = 15;
		/** <i>native declaration : include\sundials\sundials_nvector.h:28</i> */
		public static final int SUNDIALS_NVEC_CUSTOM = 16;
	};
	/**
	 * <i>native declaration : include\sundials\sundials_types.h</i><br>
	 * enum values
	 */
	public static interface SUNOutputFormat {
		/** <i>native declaration : include\sundials\sundials_types.h:111</i> */
		public static final int SUN_OUTPUTFORMAT_TABLE = 0;
		/** <i>native declaration : include\sundials\sundials_types.h:112</i> */
		public static final int SUN_OUTPUTFORMAT_CSV = 1;
	};
	/** <i>native declaration : include\sundials\sundials_direct.h</i> */
	public static final int SUNDIALS_DENSE = (int)1;
	/** <i>native declaration : include\sundials\sundials_direct.h</i> */
	public static final int SUNDIALS_BAND = (int)2;
	/** <i>native declaration : include\sundials\sundials_types.h</i> */
	public static final int SUNFALSE = (int)0;
	/** <i>native declaration : include\sundials\sundials_types.h</i> */
	public static final int SUNTRUE = (int)1;
	/** <i>native declaration : include\sundials\sundials_types.h</i> */
	public static final int SUN_COMM_NULL = (int)0;
	/** <i>native declaration : include\sundials\sundials_types.h</i> */
	public interface SUNErrHandlerFn extends Callback {
		void apply(int line, Pointer func, Pointer file, Pointer msg, int err_code, Pointer err_user_data, Pointer sunctx);
	};
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewDenseMat<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewDenseMat allocates memory for an M-by-N dense matrix<br>
	 * and returns the storage allocated (type SUNDlsMat).<br>
	 * SUNDlsMat_NewDenseMat returns NULL if the request for matrix<br>
	 * storage cannot be satisfied. See the above documentation for the<br>
	 * type SUNDlsMat for matrix storage details.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNDlsMat SUNDlsMat_NewDenseMat(sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:178</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_NewDenseMat(sunindextype, sunindextype)} and {@link #SUNDlsMat_NewDenseMat(Pointer, Pointer)} instead
	 */
	@Deprecated 
	_DlsMat SUNDlsMat_NewDenseMat(Pointer M, Pointer N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewDenseMat<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewDenseMat allocates memory for an M-by-N dense matrix<br>
	 * and returns the storage allocated (type SUNDlsMat).<br>
	 * SUNDlsMat_NewDenseMat returns NULL if the request for matrix<br>
	 * storage cannot be satisfied. See the above documentation for the<br>
	 * type SUNDlsMat for matrix storage details.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNDlsMat SUNDlsMat_NewDenseMat(sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:178</i>
	 */
	_DlsMat SUNDlsMat_NewDenseMat(sunindextype M, sunindextype N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewBandMat<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewBandMat allocates memory for an M-by-N band matrix<br>
	 * with upper bandwidth mu, lower bandwidth ml, and storage upper<br>
	 * bandwidth smu. Pass smu as follows depending on whether A will be<br>
	 * LU factored:<br>
	 * (1) Pass smu = mu if A will not be factored.<br>
	 * (2) Pass smu = MIN(N-1,mu+ml) if A will be factored.<br>
	 * SUNDlsMat_NewBandMat returns the storage allocated (type SUNDlsMat)<br>
	 * or NULL if the request for matrix storage cannot be satisfied. See<br>
	 * the documentation for the type SUNDlsMat for matrix storage<br>
	 * details.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNDlsMat SUNDlsMat_NewBandMat(sunindextype, sunindextype, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:201</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_NewBandMat(sunindextype, sunindextype, sunindextype, sunindextype)} and {@link #SUNDlsMat_NewBandMat(Pointer, Pointer, Pointer, Pointer)} instead
	 */
	@Deprecated 
	_DlsMat SUNDlsMat_NewBandMat(Pointer N, Pointer mu, Pointer ml, Pointer smu);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewBandMat<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewBandMat allocates memory for an M-by-N band matrix<br>
	 * with upper bandwidth mu, lower bandwidth ml, and storage upper<br>
	 * bandwidth smu. Pass smu as follows depending on whether A will be<br>
	 * LU factored:<br>
	 * (1) Pass smu = mu if A will not be factored.<br>
	 * (2) Pass smu = MIN(N-1,mu+ml) if A will be factored.<br>
	 * SUNDlsMat_NewBandMat returns the storage allocated (type SUNDlsMat)<br>
	 * or NULL if the request for matrix storage cannot be satisfied. See<br>
	 * the documentation for the type SUNDlsMat for matrix storage<br>
	 * details.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>SUNDlsMat SUNDlsMat_NewBandMat(sunindextype, sunindextype, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:201</i>
	 */
	_DlsMat SUNDlsMat_NewBandMat(sunindextype N, sunindextype mu, sunindextype ml, sunindextype smu);
	/**
	 * -----------------------------------------------------------------<br>
	 * Functions: SUNDlsMat_DestroyMat<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_DestroyMat frees the memory allocated by<br>
	 * SUNDlsMat_NewDenseMat or SUNDlsMat_NewBandMat<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_DestroyMat(SUNDlsMat)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:214</i>
	 */
	void SUNDlsMat_DestroyMat(_DlsMat A);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewIntArray<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewIntArray allocates memory an array of N int's and<br>
	 * returns the pointer to the memory it allocates. If the request for<br>
	 * memory storage cannot be satisfied, it returns NULL.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int* SUNDlsMat_NewIntArray(int)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:227</i>
	 */
	IntByReference SUNDlsMat_NewIntArray(int N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewIndexArray<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewIndexArray allocates memory an array of N<br>
	 * sunindextype's and returns the pointer to the memory it<br>
	 * allocates. If the request for memory storage cannot be satisfied,<br>
	 * it returns NULL.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunindextype* SUNDlsMat_NewIndexArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:241</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_NewIndexArray(sunindextype)} and {@link #SUNDlsMat_NewIndexArray(Pointer)} instead
	 */
	@Deprecated 
	PointerByReference SUNDlsMat_NewIndexArray(Pointer N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewIndexArray<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewIndexArray allocates memory an array of N<br>
	 * sunindextype's and returns the pointer to the memory it<br>
	 * allocates. If the request for memory storage cannot be satisfied,<br>
	 * it returns NULL.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunindextype* SUNDlsMat_NewIndexArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:241</i>
	 */
	PointerByReference SUNDlsMat_NewIndexArray(sunindextype N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewRealArray<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewRealArray allocates memory an array of N sunrealtype and<br>
	 * returns the pointer to the memory it allocates. If the request for<br>
	 * memory storage cannot be satisfied, it returns NULL.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunrealtype* SUNDlsMat_NewRealArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:254</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_NewRealArray(sunindextype)} and {@link #SUNDlsMat_NewRealArray(Pointer)} instead
	 */
	@Deprecated 
	sunrealtype SUNDlsMat_NewRealArray(Pointer N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_NewRealArray<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_NewRealArray allocates memory an array of N sunrealtype and<br>
	 * returns the pointer to the memory it allocates. If the request for<br>
	 * memory storage cannot be satisfied, it returns NULL.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunrealtype* SUNDlsMat_NewRealArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:254</i>
	 */
	sunrealtype SUNDlsMat_NewRealArray(sunindextype N);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function: SUNDlsMat_DestroyArray<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_DestroyArray frees memory allocated by<br>
	 * SUNDlsMat_NewIntArray, SUNDlsMat_NewIndexArray, or<br>
	 * SUNDlsMat_NewRealArray.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_DestroyArray(void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:267</i>
	 */
	void SUNDlsMat_DestroyArray(Pointer p);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNDlsMat_AddIdentity<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_AddIdentity adds 1.0 to the main diagonal (A_ii,<br>
	 * i=0,1,...,N-1) of the M-by-N matrix A (M>= N) and stores the result<br>
	 * back in A.  SUNDlsMat_AddIdentity is typically used with square<br>
	 * matrices.  SUNDlsMat_AddIdentity does not check for M >= N and<br>
	 * therefore a segmentation fault will occur if M < N!<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_AddIdentity(SUNDlsMat)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:282</i>
	 */
	void SUNDlsMat_AddIdentity(_DlsMat A);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNDlsMat_SetToZero<br>
	 * -----------------------------------------------------------------<br>
	 * SUNDlsMat_SetToZero sets all the elements of the M-by-N matrix A<br>
	 * to 0.0.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_SetToZero(SUNDlsMat)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:294</i>
	 */
	void SUNDlsMat_SetToZero(_DlsMat A);
	/**
	 * -----------------------------------------------------------------<br>
	 * Functions: SUNDlsMat_PrintMat<br>
	 * -----------------------------------------------------------------<br>
	 * This function prints the M-by-N (dense or band) matrix A to<br>
	 * outfile as it would normally appear on paper.<br>
	 * It is intended as debugging tools with small values of M and N.<br>
	 * The elements are printed using the %g/%lg/%Lg option.<br>
	 * A blank line is printed before and after the matrix.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_PrintMat(SUNDlsMat, FILE*)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:309</i>
	 */
	void SUNDlsMat_PrintMat(_DlsMat A, FILE outfile);
	/**
	 * ==================================================================<br>
	 * Exported function prototypes (functions working on sunrealtype**)<br>
	 * ==================================================================<br>
	 * Original signature : <code>sunrealtype** SUNDlsMat_newDenseMat(sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:318</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_newDenseMat(sunindextype, sunindextype)} and {@link #SUNDlsMat_newDenseMat(Pointer, Pointer)} instead
	 */
	@Deprecated 
	sunrealtype[] SUNDlsMat_newDenseMat(Pointer m, Pointer n);
	/**
	 * ==================================================================<br>
	 * Exported function prototypes (functions working on sunrealtype**)<br>
	 * ==================================================================<br>
	 * Original signature : <code>sunrealtype** SUNDlsMat_newDenseMat(sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:318</i>
	 */
	sunrealtype[] SUNDlsMat_newDenseMat(sunindextype m, sunindextype n);
	/**
	 * Original signature : <code>sunrealtype** SUNDlsMat_newBandMat(sunindextype, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:321</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_newBandMat(sunindextype, sunindextype, sunindextype)} and {@link #SUNDlsMat_newBandMat(Pointer, Pointer, Pointer)} instead
	 */
	@Deprecated 
	sunrealtype[] SUNDlsMat_newBandMat(Pointer n, Pointer smu, Pointer ml);
	/**
	 * Original signature : <code>sunrealtype** SUNDlsMat_newBandMat(sunindextype, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:321</i>
	 */
	sunrealtype[] SUNDlsMat_newBandMat(sunindextype n, sunindextype smu, sunindextype ml);
	/**
	 * Original signature : <code>void SUNDlsMat_destroyMat(sunrealtype**)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:325</i><br>
	 * @deprecated use the safer method {@link #SUNDlsMat_destroyMat(sunrealtype[])} instead
	 */
	@Deprecated 
	void SUNDlsMat_destroyMat(PointerByReference a);
	/**
	 * Original signature : <code>void SUNDlsMat_destroyMat(sunrealtype**)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:325</i>
	 */
	void SUNDlsMat_destroyMat(sunrealtype a[]);
	/**
	 * Original signature : <code>int* SUNDlsMat_newIntArray(int)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:328</i>
	 */
	IntByReference SUNDlsMat_newIntArray(int n);
	/**
	 * Original signature : <code>sunindextype* SUNDlsMat_newIndexArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:331</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_newIndexArray(sunindextype)} and {@link #SUNDlsMat_newIndexArray(Pointer)} instead
	 */
	@Deprecated 
	PointerByReference SUNDlsMat_newIndexArray(Pointer n);
	/**
	 * Original signature : <code>sunindextype* SUNDlsMat_newIndexArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:331</i>
	 */
	PointerByReference SUNDlsMat_newIndexArray(sunindextype n);
	/**
	 * Original signature : <code>sunrealtype* SUNDlsMat_newRealArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:334</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_newRealArray(sunindextype)} and {@link #SUNDlsMat_newRealArray(Pointer)} instead
	 */
	@Deprecated 
	sunrealtype SUNDlsMat_newRealArray(Pointer m);
	/**
	 * Original signature : <code>sunrealtype* SUNDlsMat_newRealArray(sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:334</i>
	 */
	sunrealtype SUNDlsMat_newRealArray(sunindextype m);
	/**
	 * Original signature : <code>void SUNDlsMat_destroyArray(void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_direct.h:337</i>
	 */
	void SUNDlsMat_destroyArray(Pointer v);
	/**
	 * -----------------------------------------------------------------<br>
	 * Functions exported by NVECTOR module<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>N_Vector N_VNewEmpty(SUNContext)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:155</i><br>
	 * @deprecated use the safer methods {@link #N_VNewEmpty(SUNContext)} and {@link #N_VNewEmpty(Pointer)} instead
	 */
	@Deprecated 
	N_Vector N_VNewEmpty(Pointer sunctx);
	/**
	 * -----------------------------------------------------------------<br>
	 * Functions exported by NVECTOR module<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>N_Vector N_VNewEmpty(SUNContext)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:155</i>
	 */
	N_Vector N_VNewEmpty(SUNContext sunctx);
	/**
	 * Original signature : <code>void N_VFreeEmpty(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:156</i>
	 */
	void N_VFreeEmpty(N_Vector v);
	/**
	 * Original signature : <code>SUNErrCode N_VCopyOps(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:157</i>
	 */
	int N_VCopyOps(N_Vector w, N_Vector v);
	/**
	 * Required operations.<br>
	 * Original signature : <code>N_Vector_ID N_VGetVectorID(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:163</i>
	 */
	int N_VGetVectorID(N_Vector w);
	/**
	 * Original signature : <code>N_Vector N_VClone(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:164</i>
	 */
	N_Vector N_VClone(N_Vector w);
	/**
	 * Original signature : <code>N_Vector N_VCloneEmpty(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:165</i>
	 */
	N_Vector N_VCloneEmpty(N_Vector w);
	/**
	 * Original signature : <code>void N_VDestroy(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:166</i>
	 */
	void N_VDestroy(N_Vector v);
	/**
	 * Original signature : <code>void N_VSpace(N_Vector, sunindextype*, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:167</i><br>
	 * @deprecated use the safer method {@link #N_VSpace(N_Vector, PointerByReference, PointerByReference)} instead
	 */
	@Deprecated 
	void N_VSpace(N_Vector v, Pointer lrw, Pointer liw);
	/**
	 * Original signature : <code>void N_VSpace(N_Vector, sunindextype*, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:167</i>
	 */
	void N_VSpace(N_Vector v, PointerByReference lrw, PointerByReference liw);
	/**
	 * Original signature : <code>sunrealtype* N_VGetArrayPointer(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:168</i>
	 */
	sunrealtype N_VGetArrayPointer(N_Vector v);
	/**
	 * Original signature : <code>sunrealtype* N_VGetDeviceArrayPointer(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:169</i>
	 */
	sunrealtype N_VGetDeviceArrayPointer(N_Vector v);
	/**
	 * Original signature : <code>void N_VSetArrayPointer(sunrealtype*, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:170</i>
	 */
	void N_VSetArrayPointer(sunrealtype v_data, N_Vector v);
	/**
	 * Original signature : <code>SUNComm N_VGetCommunicator(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:171</i>
	 */
	int N_VGetCommunicator(N_Vector v);
	/**
	 * Original signature : <code>sunindextype N_VGetLength(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:172</i>
	 */
	sunindextype N_VGetLength(N_Vector v);
	/**
	 * Original signature : <code>sunindextype N_VGetLocalLength(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:173</i>
	 */
	sunindextype N_VGetLocalLength(N_Vector v);
	/**
	 * standard vector operations<br>
	 * Original signature : <code>void N_VLinearSum(sunrealtype, N_Vector, sunrealtype, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:176</i>
	 */
	void N_VLinearSum(sunrealtype a, N_Vector x, sunrealtype b, N_Vector y, N_Vector z);
	/**
	 * Original signature : <code>void N_VConst(sunrealtype, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:178</i>
	 */
	void N_VConst(sunrealtype c, N_Vector z);
	/**
	 * Original signature : <code>void N_VProd(N_Vector, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:179</i>
	 */
	void N_VProd(N_Vector x, N_Vector y, N_Vector z);
	/**
	 * Original signature : <code>void N_VDiv(N_Vector, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:180</i>
	 */
	void N_VDiv(N_Vector x, N_Vector y, N_Vector z);
	/**
	 * Original signature : <code>void N_VScale(sunrealtype, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:181</i>
	 */
	void N_VScale(sunrealtype c, N_Vector x, N_Vector z);
	/**
	 * Original signature : <code>void N_VAbs(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:182</i>
	 */
	void N_VAbs(N_Vector x, N_Vector z);
	/**
	 * Original signature : <code>void N_VInv(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:183</i>
	 */
	void N_VInv(N_Vector x, N_Vector z);
	/**
	 * Original signature : <code>void N_VAddConst(N_Vector, sunrealtype, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:184</i>
	 */
	void N_VAddConst(N_Vector x, sunrealtype b, N_Vector z);
	/**
	 * Original signature : <code>sunrealtype N_VDotProd(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:185</i>
	 */
	sunrealtype N_VDotProd(N_Vector x, N_Vector y);
	/**
	 * Original signature : <code>sunrealtype N_VMaxNorm(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:186</i>
	 */
	sunrealtype N_VMaxNorm(N_Vector x);
	/**
	 * Original signature : <code>sunrealtype N_VWrmsNorm(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:187</i>
	 */
	sunrealtype N_VWrmsNorm(N_Vector x, N_Vector w);
	/**
	 * Original signature : <code>sunrealtype N_VWrmsNormMask(N_Vector, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:188</i>
	 */
	sunrealtype N_VWrmsNormMask(N_Vector x, N_Vector w, N_Vector id);
	/**
	 * Original signature : <code>sunrealtype N_VMin(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:189</i>
	 */
	sunrealtype N_VMin(N_Vector x);
	/**
	 * Original signature : <code>sunrealtype N_VWL2Norm(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:190</i>
	 */
	sunrealtype N_VWL2Norm(N_Vector x, N_Vector w);
	/**
	 * Original signature : <code>sunrealtype N_VL1Norm(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:191</i>
	 */
	sunrealtype N_VL1Norm(N_Vector x);
	/**
	 * Original signature : <code>void N_VCompare(sunrealtype, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:192</i>
	 */
	void N_VCompare(sunrealtype c, N_Vector x, N_Vector z);
	/**
	 * Original signature : <code>sunbooleantype N_VInvTest(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:193</i>
	 */
	int N_VInvTest(N_Vector x, N_Vector z);
	/**
	 * Original signature : <code>sunbooleantype N_VConstrMask(N_Vector, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:194</i>
	 */
	int N_VConstrMask(N_Vector c, N_Vector x, N_Vector m);
	/**
	 * Original signature : <code>sunrealtype N_VMinQuotient(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:195</i>
	 */
	sunrealtype N_VMinQuotient(N_Vector num, N_Vector denom);
	/**
	 * fused vector operations<br>
	 * Original signature : <code>SUNErrCode N_VLinearCombination(int, sunrealtype*, N_Vector*, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:203</i>
	 */
	int N_VLinearCombination(int nvec, sunrealtype c, N_Vector X, N_Vector z);
	/**
	 * Original signature : <code>SUNErrCode N_VScaleAddMulti(int, sunrealtype*, N_Vector, N_Vector*, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:207</i>
	 */
	int N_VScaleAddMulti(int nvec, sunrealtype a, N_Vector x, N_Vector Y, N_Vector Z);
	/**
	 * Original signature : <code>SUNErrCode N_VDotProdMulti(int, N_Vector, N_Vector*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:211</i>
	 */
	int N_VDotProdMulti(int nvec, N_Vector x, N_Vector Y, sunrealtype dotprods);
	/**
	 * vector array operations<br>
	 * Original signature : <code>SUNErrCode N_VLinearSumVectorArray(int, sunrealtype, N_Vector*, sunrealtype, N_Vector*, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:216</i>
	 */
	int N_VLinearSumVectorArray(int nvec, sunrealtype a, N_Vector X, sunrealtype b, N_Vector Y, N_Vector Z);
	/**
	 * Original signature : <code>SUNErrCode N_VScaleVectorArray(int, sunrealtype*, N_Vector*, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:220</i>
	 */
	int N_VScaleVectorArray(int nvec, sunrealtype c, N_Vector X, N_Vector Z);
	/**
	 * Original signature : <code>SUNErrCode N_VConstVectorArray(int, sunrealtype, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:224</i>
	 */
	int N_VConstVectorArray(int nvec, sunrealtype c, N_Vector Z);
	/**
	 * Original signature : <code>SUNErrCode N_VWrmsNormVectorArray(int, N_Vector*, N_Vector*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:227</i>
	 */
	int N_VWrmsNormVectorArray(int nvec, N_Vector X, N_Vector W, sunrealtype nrm);
	/**
	 * Original signature : <code>SUNErrCode N_VWrmsNormMaskVectorArray(int, N_Vector*, N_Vector*, N_Vector, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:231</i>
	 */
	int N_VWrmsNormMaskVectorArray(int nvec, N_Vector X, N_Vector W, N_Vector id, sunrealtype nrm);
	/**
	 * Original signature : <code>SUNErrCode N_VScaleAddMultiVectorArray(int, int, sunrealtype*, N_Vector*, N_Vector**, N_Vector**)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:235</i><br>
	 * @deprecated use the safer method {@link #N_VScaleAddMultiVectorArray(int, int, sunrealtype, N_Vector, N_Vector[], N_Vector[])} instead
	 */
	@Deprecated 
	int N_VScaleAddMultiVectorArray(int nvec, int nsum, sunrealtype a, N_Vector X, PointerByReference Y, PointerByReference Z);
	/**
	 * Original signature : <code>SUNErrCode N_VScaleAddMultiVectorArray(int, int, sunrealtype*, N_Vector*, N_Vector**, N_Vector**)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:235</i>
	 */
	int N_VScaleAddMultiVectorArray(int nvec, int nsum, sunrealtype a, N_Vector X, N_Vector Y[], N_Vector Z[]);
	/**
	 * Original signature : <code>SUNErrCode N_VLinearCombinationVectorArray(int, int, sunrealtype*, N_Vector**, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:239</i><br>
	 * @deprecated use the safer method {@link #N_VLinearCombinationVectorArray(int, int, sunrealtype, N_Vector[], N_Vector)} instead
	 */
	@Deprecated 
	int N_VLinearCombinationVectorArray(int nvec, int nsum, sunrealtype c, PointerByReference X, N_Vector Z);
	/**
	 * Original signature : <code>SUNErrCode N_VLinearCombinationVectorArray(int, int, sunrealtype*, N_Vector**, N_Vector*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:239</i>
	 */
	int N_VLinearCombinationVectorArray(int nvec, int nsum, sunrealtype c, N_Vector X[], N_Vector Z);
	/**
	 * local reduction kernels (no parallel communication)<br>
	 * Original signature : <code>sunrealtype N_VDotProdLocal(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:247</i>
	 */
	sunrealtype N_VDotProdLocal(N_Vector x, N_Vector y);
	/**
	 * Original signature : <code>sunrealtype N_VMaxNormLocal(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:248</i>
	 */
	sunrealtype N_VMaxNormLocal(N_Vector x);
	/**
	 * Original signature : <code>sunrealtype N_VMinLocal(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:249</i>
	 */
	sunrealtype N_VMinLocal(N_Vector x);
	/**
	 * Original signature : <code>sunrealtype N_VL1NormLocal(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:250</i>
	 */
	sunrealtype N_VL1NormLocal(N_Vector x);
	/**
	 * Original signature : <code>sunrealtype N_VWSqrSumLocal(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:251</i>
	 */
	sunrealtype N_VWSqrSumLocal(N_Vector x, N_Vector w);
	/**
	 * Original signature : <code>sunrealtype N_VWSqrSumMaskLocal(N_Vector, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:252</i>
	 */
	sunrealtype N_VWSqrSumMaskLocal(N_Vector x, N_Vector w, N_Vector id);
	/**
	 * Original signature : <code>sunbooleantype N_VInvTestLocal(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:254</i>
	 */
	int N_VInvTestLocal(N_Vector x, N_Vector z);
	/**
	 * Original signature : <code>sunbooleantype N_VConstrMaskLocal(N_Vector, N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:255</i>
	 */
	int N_VConstrMaskLocal(N_Vector c, N_Vector x, N_Vector m);
	/**
	 * Original signature : <code>sunrealtype N_VMinQuotientLocal(N_Vector, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:257</i>
	 */
	sunrealtype N_VMinQuotientLocal(N_Vector num, N_Vector denom);
	/**
	 * single buffer reduction operations<br>
	 * Original signature : <code>SUNErrCode N_VDotProdMultiLocal(int, N_Vector, N_Vector*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:260</i>
	 */
	int N_VDotProdMultiLocal(int nvec, N_Vector x, N_Vector Y, sunrealtype dotprods);
	/**
	 * Original signature : <code>SUNErrCode N_VDotProdMultiAllReduce(int, N_Vector, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:262</i>
	 */
	int N_VDotProdMultiAllReduce(int nvec_total, N_Vector x, sunrealtype sum);
	/**
	 * XBraid interface operations<br>
	 * Original signature : <code>SUNErrCode N_VBufSize(N_Vector, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:266</i><br>
	 * @deprecated use the safer method {@link #N_VBufSize(N_Vector, PointerByReference)} instead
	 */
	@Deprecated 
	int N_VBufSize(N_Vector x, Pointer size);
	/**
	 * XBraid interface operations<br>
	 * Original signature : <code>SUNErrCode N_VBufSize(N_Vector, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:266</i>
	 */
	int N_VBufSize(N_Vector x, PointerByReference size);
	/**
	 * Original signature : <code>SUNErrCode N_VBufPack(N_Vector, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:267</i>
	 */
	int N_VBufPack(N_Vector x, Pointer buf);
	/**
	 * Original signature : <code>SUNErrCode N_VBufUnpack(N_Vector, void*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:268</i>
	 */
	int N_VBufUnpack(N_Vector x, Pointer buf);
	/**
	 * -----------------------------------------------------------------<br>
	 * Additional functions exported by NVECTOR module<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>N_Vector* N_VNewVectorArray(int, SUNContext)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:274</i><br>
	 * @deprecated use the safer methods {@link #N_VNewVectorArray(int, SUNContext)} and {@link #N_VNewVectorArray(int, Pointer)} instead
	 */
	@Deprecated 
	N_Vector N_VNewVectorArray(int count, Pointer sunctx);
	/**
	 * -----------------------------------------------------------------<br>
	 * Additional functions exported by NVECTOR module<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>N_Vector* N_VNewVectorArray(int, SUNContext)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:274</i>
	 */
	N_Vector N_VNewVectorArray(int count, SUNContext sunctx);
	/**
	 * Original signature : <code>N_Vector* N_VCloneEmptyVectorArray(int, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:275</i>
	 */
	N_Vector N_VCloneEmptyVectorArray(int count, N_Vector w);
	/**
	 * Original signature : <code>N_Vector* N_VCloneVectorArray(int, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:276</i>
	 */
	N_Vector N_VCloneVectorArray(int count, N_Vector w);
	/**
	 * Original signature : <code>void N_VDestroyVectorArray(N_Vector*, int)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:277</i>
	 */
	void N_VDestroyVectorArray(N_Vector vs, int count);
	/**
	 * These function are really only for users of the Fortran interface<br>
	 * Original signature : <code>N_Vector N_VGetVecAtIndexVectorArray(N_Vector*, int)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:280</i>
	 */
	N_Vector N_VGetVecAtIndexVectorArray(N_Vector vs, int index);
	/**
	 * Original signature : <code>void N_VSetVecAtIndexVectorArray(N_Vector*, int, N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:281</i>
	 */
	void N_VSetVecAtIndexVectorArray(N_Vector vs, int index, N_Vector w);
	/**
	 * -----------------------------------------------------------------<br>
	 * Debugging functions<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>void N_VPrint(N_Vector)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:288</i>
	 */
	void N_VPrint(N_Vector v);
	/**
	 * Original signature : <code>void N_VPrintFile(N_Vector, FILE*)</code><br>
	 * <i>native declaration : include\sundials\sundials_nvector.h:289</i>
	 */
	void N_VPrintFile(N_Vector v, FILE outfile);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNRpowerI<br>
	 * -----------------------------------------------------------------<br>
	 * Usage : int exponent;<br>
	 *         sunrealtype base, ans;<br>
	 *         ans = SUNRpowerI(base,exponent);<br>
	 * -----------------------------------------------------------------<br>
	 * SUNRpowerI returns the value of base^exponent, where base is of type<br>
	 * sunrealtype and exponent is of type int.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunrealtype SUNRpowerI(sunrealtype, int)</code><br>
	 * <i>native declaration : include\sundials\sundials_math.h:140</i>
	 */
	sunrealtype SUNRpowerI(sunrealtype base, int exponent);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNRpowerR<br>
	 * -----------------------------------------------------------------<br>
	 * Usage : sunrealtype base, exponent, ans;<br>
	 *         ans = SUNRpowerR(base,exponent);<br>
	 * -----------------------------------------------------------------<br>
	 * SUNRpowerR returns the value of base^exponent, where both base and<br>
	 * exponent are of type sunrealtype. If base < ZERO, then SUNRpowerR<br>
	 * returns ZERO.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunrealtype SUNRpowerR(sunrealtype, sunrealtype)</code><br>
	 * <i>native declaration : include\sundials\sundials_math.h:155</i>
	 */
	sunrealtype SUNRpowerR(sunrealtype base, sunrealtype exponent);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNRCompare<br>
	 * -----------------------------------------------------------------<br>
	 * Usage : int isNotEqual;<br>
	 *         sunrealtype a, b;<br>
	 *         isNotEqual = SUNRCompare(a, b);<br>
	 * -----------------------------------------------------------------<br>
	 * SUNRCompareTol returns 0 if the relative difference of a and b is<br>
	 * less than or equal to 10*machine epsilon. If the relative<br>
	 * difference is greater than 10*machine epsilon, it returns 1. The<br>
	 * function handles the case where a or b are near zero as well as<br>
	 * the case where a or b are inf/nan.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int SUNRCompare(sunrealtype, sunrealtype)</code><br>
	 * <i>native declaration : include\sundials\sundials_math.h:173</i>
	 */
	int SUNRCompare(sunrealtype a, sunrealtype b);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNRCompareTol<br>
	 * -----------------------------------------------------------------<br>
	 * Usage : int isNotEqual;<br>
	 *         sunrealtype a, b, tol;<br>
	 *         isNotEqual = SUNRCompareTol(a, b, tol);<br>
	 * -----------------------------------------------------------------<br>
	 * SUNRCompareTol returns 0 if the relative difference of a and b is<br>
	 * less than or equal to the provided tolerance. If the relative<br>
	 * difference is greater than the tolerance, it returns 1. The<br>
	 * function handles the case where a or b are near zero as well as<br>
	 * the case where a or b are inf/nan.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>int SUNRCompareTol(sunrealtype, sunrealtype, sunrealtype)</code><br>
	 * <i>native declaration : include\sundials\sundials_math.h:191</i>
	 */
	int SUNRCompareTol(sunrealtype a, sunrealtype b, sunrealtype tol);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNStrToReal<br>
	 * -----------------------------------------------------------------<br>
	 * Usage : sunrealtype a = SUNStrToReal(const char* str)<br>
	 * -----------------------------------------------------------------<br>
	 * SUNStrToReal parses str into the sunrealtype variable. Uses standard<br>
	 * strtod variants when they are available.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunrealtype SUNStrToReal(const char*)</code><br>
	 * <i>native declaration : include\sundials\sundials_math.h:205</i><br>
	 * @deprecated use the safer methods {@link #SUNStrToReal(String)} and {@link #SUNStrToReal(Pointer)} instead
	 */
	@Deprecated 
	sunrealtype SUNStrToReal(Pointer str);
	/**
	 * -----------------------------------------------------------------<br>
	 * Function : SUNStrToReal<br>
	 * -----------------------------------------------------------------<br>
	 * Usage : sunrealtype a = SUNStrToReal(const char* str)<br>
	 * -----------------------------------------------------------------<br>
	 * SUNStrToReal parses str into the sunrealtype variable. Uses standard<br>
	 * strtod variants when they are available.<br>
	 * -----------------------------------------------------------------<br>
	 * Original signature : <code>sunrealtype SUNStrToReal(const char*)</code><br>
	 * <i>native declaration : include\sundials\sundials_math.h:205</i>
	 */
	sunrealtype SUNStrToReal(String str);
	/**
	 * ----------------------------------------------------------------------------<br>
	 * Functions: SUNDlsMat_DenseGETRF and SUNDlsMat_DenseGETRS<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseGETRF performs the LU factorization of the M by N dense matrix A.<br>
	 * This is done using standard Gaussian elimination with partial (row) pivoting.<br>
	 * Note that this applies only to matrices with M >= N and full column rank.<br>
	 * A successful LU factorization leaves the matrix A and the pivot array p with<br>
	 * the following information:<br>
	 * (1) p[k] contains the row number of the pivot element chosen at the beginning<br>
	 *     of elimination step k, k=0, 1, ..., N-1.<br>
	 * (2) If the unique LU factorization of A is given by PA = LU, where P is a<br>
	 *     permutation matrix, L is a lower trapezoidal matrix with all 1's on the<br>
	 *     diagonal, and U is an upper triangular matrix, then the upper triangular<br>
	 *     part of A (including its diagonal) contains U and the strictly lower<br>
	 *     trapezoidal part of A contains the multipliers, I-L.<br>
	 * For square matrices (M = N), L is unit lower triangular.<br>
	 * SUNDlsMat_DenseGETRF returns 0 if successful. Otherwise it encountered a zero<br>
	 * diagonal element during the factorization. In this case it returns the column<br>
	 * index (numbered from one) at which it encountered the zero.<br>
	 * SUNDlsMat_DenseGETRS solves the N-dimensional system A x = b using the LU<br>
	 * factorization in A and the pivot information in p computed in<br>
	 * SUNDlsMat_DenseGETRF. The solution x is returned in b. This routine cannot fail<br>
	 * if the corresponding call to SUNDlsMat_DenseGETRF did not fail.<br>
	 * SUNDlsMat_DenseGETRS does NOT check for a square matrix!<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseGETRF and SUNDlsMat_DenseGETRS are simply wrappers around<br>
	 * SUNDlsMat_denseGETRF and SUNDlsMat_denseGETRS, respectively, which perform all the<br>
	 * work by directly accessing the data in the SUNDlsMat A (i.e. in A->cols).<br>
	 * ----------------------------------------------------------------------------<br>
	 * Original signature : <code>sunindextype SUNDlsMat_DenseGETRF(SUNDlsMat, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:46</i><br>
	 * @deprecated use the safer method {@link #SUNDlsMat_DenseGETRF(_DlsMat, PointerByReference)} instead
	 */
	@Deprecated 
	sunindextype SUNDlsMat_DenseGETRF(_DlsMat A, Pointer p);
	/**
	 * ----------------------------------------------------------------------------<br>
	 * Functions: SUNDlsMat_DenseGETRF and SUNDlsMat_DenseGETRS<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseGETRF performs the LU factorization of the M by N dense matrix A.<br>
	 * This is done using standard Gaussian elimination with partial (row) pivoting.<br>
	 * Note that this applies only to matrices with M >= N and full column rank.<br>
	 * A successful LU factorization leaves the matrix A and the pivot array p with<br>
	 * the following information:<br>
	 * (1) p[k] contains the row number of the pivot element chosen at the beginning<br>
	 *     of elimination step k, k=0, 1, ..., N-1.<br>
	 * (2) If the unique LU factorization of A is given by PA = LU, where P is a<br>
	 *     permutation matrix, L is a lower trapezoidal matrix with all 1's on the<br>
	 *     diagonal, and U is an upper triangular matrix, then the upper triangular<br>
	 *     part of A (including its diagonal) contains U and the strictly lower<br>
	 *     trapezoidal part of A contains the multipliers, I-L.<br>
	 * For square matrices (M = N), L is unit lower triangular.<br>
	 * SUNDlsMat_DenseGETRF returns 0 if successful. Otherwise it encountered a zero<br>
	 * diagonal element during the factorization. In this case it returns the column<br>
	 * index (numbered from one) at which it encountered the zero.<br>
	 * SUNDlsMat_DenseGETRS solves the N-dimensional system A x = b using the LU<br>
	 * factorization in A and the pivot information in p computed in<br>
	 * SUNDlsMat_DenseGETRF. The solution x is returned in b. This routine cannot fail<br>
	 * if the corresponding call to SUNDlsMat_DenseGETRF did not fail.<br>
	 * SUNDlsMat_DenseGETRS does NOT check for a square matrix!<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseGETRF and SUNDlsMat_DenseGETRS are simply wrappers around<br>
	 * SUNDlsMat_denseGETRF and SUNDlsMat_denseGETRS, respectively, which perform all the<br>
	 * work by directly accessing the data in the SUNDlsMat A (i.e. in A->cols).<br>
	 * ----------------------------------------------------------------------------<br>
	 * Original signature : <code>sunindextype SUNDlsMat_DenseGETRF(SUNDlsMat, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:46</i>
	 */
	sunindextype SUNDlsMat_DenseGETRF(_DlsMat A, PointerByReference p);
	/**
	 * Original signature : <code>void SUNDlsMat_DenseGETRS(SUNDlsMat, sunindextype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:49</i><br>
	 * @deprecated use the safer method {@link #SUNDlsMat_DenseGETRS(_DlsMat, PointerByReference, sunrealtype)} instead
	 */
	@Deprecated 
	void SUNDlsMat_DenseGETRS(_DlsMat A, Pointer p, sunrealtype b);
	/**
	 * Original signature : <code>void SUNDlsMat_DenseGETRS(SUNDlsMat, sunindextype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:49</i>
	 */
	void SUNDlsMat_DenseGETRS(_DlsMat A, PointerByReference p, sunrealtype b);
	/**
	 * Original signature : <code>sunindextype SUNDlsMat_denseGETRF(sunrealtype**, sunindextype, sunindextype, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:52</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseGETRF(sunrealtype[], sunindextype, sunindextype, PointerByReference)} and {@link #SUNDlsMat_denseGETRF(sunrealtype[], Pointer, Pointer, PointerByReference)} instead
	 */
	@Deprecated 
	sunindextype SUNDlsMat_denseGETRF(PointerByReference a, Pointer m, Pointer n, Pointer p);
	/**
	 * Original signature : <code>sunindextype SUNDlsMat_denseGETRF(sunrealtype**, sunindextype, sunindextype, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:52</i>
	 */
	sunindextype SUNDlsMat_denseGETRF(sunrealtype a[], sunindextype m, sunindextype n, PointerByReference p);
	/**
	 * Original signature : <code>sunindextype SUNDlsMat_denseGETRF(sunrealtype**, sunindextype, sunindextype, sunindextype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:52</i>
	 */
	sunindextype SUNDlsMat_denseGETRF(sunrealtype a[], Pointer m, Pointer n, PointerByReference p);
	/**
	 * Original signature : <code>void SUNDlsMat_denseGETRS(sunrealtype**, sunindextype, sunindextype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:56</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseGETRS(sunrealtype[], sunindextype, PointerByReference, sunrealtype)} and {@link #SUNDlsMat_denseGETRS(sunrealtype[], Pointer, PointerByReference, sunrealtype)} instead
	 */
	@Deprecated 
	void SUNDlsMat_denseGETRS(PointerByReference a, Pointer n, Pointer p, sunrealtype b);
	/**
	 * Original signature : <code>void SUNDlsMat_denseGETRS(sunrealtype**, sunindextype, sunindextype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:56</i>
	 */
	void SUNDlsMat_denseGETRS(sunrealtype a[], sunindextype n, PointerByReference p, sunrealtype b);
	/**
	 * Original signature : <code>void SUNDlsMat_denseGETRS(sunrealtype**, sunindextype, sunindextype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:56</i>
	 */
	void SUNDlsMat_denseGETRS(sunrealtype a[], Pointer n, PointerByReference p, sunrealtype b);
	/**
	 * ----------------------------------------------------------------------------<br>
	 * Functions : SUNDlsMat_DensePOTRF and SUNDlsMat_DensePOTRS<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DensePOTRF computes the Cholesky factorization of a real symmetric<br>
	 * positive definite matrix A.<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DensePOTRS solves a system of linear equations A*X = B with a<br>
	 * symmetric positive definite matrix A using the Cholesky factorization A =<br>
	 * L*L**T computed by SUNDlsMat_DensePOTRF.<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DensePOTRF and SUNDlsMat_DensePOTRS are simply wrappers around<br>
	 * SUNDlsMat_densePOTRF and SUNDlsMat_densePOTRS, respectively, which perform all the<br>
	 * work by directly accessing the data in the DlsMat A (i.e. the field cols)<br>
	 * ----------------------------------------------------------------------------<br>
	 * Original signature : <code>sunindextype SUNDlsMat_DensePOTRF(SUNDlsMat)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:78</i>
	 */
	sunindextype SUNDlsMat_DensePOTRF(_DlsMat A);
	/**
	 * Original signature : <code>void SUNDlsMat_DensePOTRS(SUNDlsMat, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:81</i>
	 */
	void SUNDlsMat_DensePOTRS(_DlsMat A, sunrealtype b);
	/**
	 * Original signature : <code>sunindextype SUNDlsMat_densePOTRF(sunrealtype**, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:84</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_densePOTRF(sunrealtype[], sunindextype)} and {@link #SUNDlsMat_densePOTRF(sunrealtype[], Pointer)} instead
	 */
	@Deprecated 
	sunindextype SUNDlsMat_densePOTRF(PointerByReference a, Pointer m);
	/**
	 * Original signature : <code>sunindextype SUNDlsMat_densePOTRF(sunrealtype**, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:84</i>
	 */
	sunindextype SUNDlsMat_densePOTRF(sunrealtype a[], sunindextype m);
	/**
	 * Original signature : <code>sunindextype SUNDlsMat_densePOTRF(sunrealtype**, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:84</i>
	 */
	sunindextype SUNDlsMat_densePOTRF(sunrealtype a[], Pointer m);
	/**
	 * Original signature : <code>void SUNDlsMat_densePOTRS(sunrealtype**, sunindextype, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:87</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_densePOTRS(sunrealtype[], sunindextype, sunrealtype)} and {@link #SUNDlsMat_densePOTRS(sunrealtype[], Pointer, sunrealtype)} instead
	 */
	@Deprecated 
	void SUNDlsMat_densePOTRS(PointerByReference a, Pointer m, sunrealtype b);
	/**
	 * Original signature : <code>void SUNDlsMat_densePOTRS(sunrealtype**, sunindextype, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:87</i>
	 */
	void SUNDlsMat_densePOTRS(sunrealtype a[], sunindextype m, sunrealtype b);
	/**
	 * Original signature : <code>void SUNDlsMat_densePOTRS(sunrealtype**, sunindextype, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:87</i>
	 */
	void SUNDlsMat_densePOTRS(sunrealtype a[], Pointer m, sunrealtype b);
	/**
	 * -----------------------------------------------------------------------------<br>
	 * Functions : SUNDlsMat_DenseGEQRF and SUNDlsMat_DenseORMQR<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseGEQRF computes a QR factorization of a real M-by-N matrix A: A =<br>
	 * Q * R (with M>= N).<br>
	 * SUNDlsMat_DenseGEQRF requires a temporary work vector wrk of length M.<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseORMQR computes the product w = Q * v where Q is a real orthogonal<br>
	 * matrix defined as the product of k elementary reflectors<br>
	 *        Q = H(1) H(2) . . . H(k)<br>
	 * as returned by SUNDlsMat_DenseGEQRF. Q is an M-by-N matrix, v is a vector of<br>
	 * length N and w is a vector of length M (with M >= N).<br>
	 * SUNDlsMat_DenseORMQR requires a temporary work vector wrk of length M.<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseGEQRF and SUNDlsMat_DenseORMQR are simply wrappers around<br>
	 * SUNDlsMat_denseGEQRF and SUNDlsMat_denseORMQR, respectively, which perform all the<br>
	 * work by directly accessing the data in the DlsMat A (i.e. the field cols)<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>int SUNDlsMat_DenseGEQRF(SUNDlsMat, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:116</i>
	 */
	int SUNDlsMat_DenseGEQRF(_DlsMat A, sunrealtype beta, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_DenseORMQR(SUNDlsMat, sunrealtype*, sunrealtype*, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:119</i>
	 */
	int SUNDlsMat_DenseORMQR(_DlsMat A, sunrealtype beta, sunrealtype vn, sunrealtype vm, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_denseGEQRF(sunrealtype**, sunindextype, sunindextype, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:123</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseGEQRF(sunrealtype[], sunindextype, sunindextype, sunrealtype, sunrealtype)} and {@link #SUNDlsMat_denseGEQRF(sunrealtype[], Pointer, Pointer, sunrealtype, sunrealtype)} instead
	 */
	@Deprecated 
	int SUNDlsMat_denseGEQRF(PointerByReference a, Pointer m, Pointer n, sunrealtype beta, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_denseGEQRF(sunrealtype**, sunindextype, sunindextype, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:123</i>
	 */
	int SUNDlsMat_denseGEQRF(sunrealtype a[], sunindextype m, sunindextype n, sunrealtype beta, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_denseGEQRF(sunrealtype**, sunindextype, sunindextype, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:123</i>
	 */
	int SUNDlsMat_denseGEQRF(sunrealtype a[], Pointer m, Pointer n, sunrealtype beta, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_denseORMQR(sunrealtype**, sunindextype, sunindextype, sunrealtype*, sunrealtype*, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:127</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseORMQR(sunrealtype[], sunindextype, sunindextype, sunrealtype, sunrealtype, sunrealtype, sunrealtype)} and {@link #SUNDlsMat_denseORMQR(sunrealtype[], Pointer, Pointer, sunrealtype, sunrealtype, sunrealtype, sunrealtype)} instead
	 */
	@Deprecated 
	int SUNDlsMat_denseORMQR(PointerByReference a, Pointer m, Pointer n, sunrealtype beta, sunrealtype v, sunrealtype w, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_denseORMQR(sunrealtype**, sunindextype, sunindextype, sunrealtype*, sunrealtype*, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:127</i>
	 */
	int SUNDlsMat_denseORMQR(sunrealtype a[], sunindextype m, sunindextype n, sunrealtype beta, sunrealtype v, sunrealtype w, sunrealtype wrk);
	/**
	 * Original signature : <code>int SUNDlsMat_denseORMQR(sunrealtype**, sunindextype, sunindextype, sunrealtype*, sunrealtype*, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:127</i>
	 */
	int SUNDlsMat_denseORMQR(sunrealtype a[], Pointer m, Pointer n, sunrealtype beta, sunrealtype v, sunrealtype w, sunrealtype wrk);
	/**
	 * ----------------------------------------------------------------------------<br>
	 * Function : SUNDlsMat_DenseCopy<br>
	 * ----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseCopy copies the contents of the M-by-N matrix A into the<br>
	 * M-by-N matrix B.<br>
	 * SUNDlsMat_DenseCopy is a wrapper around SUNDlsMat_denseCopy which accesses<br>
	 * the data in the SUNDlsMat A and SUNDlsMat B (i.e. the fields cols)<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_DenseCopy(SUNDlsMat, SUNDlsMat)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:144</i>
	 */
	void SUNDlsMat_DenseCopy(_DlsMat A, _DlsMat B);
	/**
	 * Original signature : <code>void SUNDlsMat_denseCopy(sunrealtype**, sunrealtype**, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:147</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseCopy(sunrealtype[], sunrealtype[], sunindextype, sunindextype)} and {@link #SUNDlsMat_denseCopy(sunrealtype[], sunrealtype[], Pointer, Pointer)} instead
	 */
	@Deprecated 
	void SUNDlsMat_denseCopy(PointerByReference a, PointerByReference b, Pointer m, Pointer n);
	/**
	 * Original signature : <code>void SUNDlsMat_denseCopy(sunrealtype**, sunrealtype**, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:147</i>
	 */
	void SUNDlsMat_denseCopy(sunrealtype a[], sunrealtype b[], sunindextype m, sunindextype n);
	/**
	 * Original signature : <code>void SUNDlsMat_denseCopy(sunrealtype**, sunrealtype**, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:147</i>
	 */
	void SUNDlsMat_denseCopy(sunrealtype a[], sunrealtype b[], Pointer m, Pointer n);
	/**
	 * -----------------------------------------------------------------------------<br>
	 * Function: SUNDlsMat_DenseScale<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseScale scales the elements of the M-by-N matrix A by the<br>
	 * constant c and stores the result back in A.<br>
	 * SUNDlsMat_DenseScale is a wrapper around SUNDlsMat_denseScale which performs<br>
	 * the actual scaling by accessing the data in the SUNDlsMat A (i.e. in<br>
	 * A->cols).<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_DenseScale(sunrealtype, SUNDlsMat)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:164</i>
	 */
	void SUNDlsMat_DenseScale(sunrealtype c, _DlsMat A);
	/**
	 * Original signature : <code>void SUNDlsMat_denseScale(sunrealtype, sunrealtype**, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:167</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseScale(sunrealtype, sunrealtype[], sunindextype, sunindextype)} and {@link #SUNDlsMat_denseScale(sunrealtype, sunrealtype[], Pointer, Pointer)} instead
	 */
	@Deprecated 
	void SUNDlsMat_denseScale(sunrealtype c, PointerByReference a, Pointer m, Pointer n);
	/**
	 * Original signature : <code>void SUNDlsMat_denseScale(sunrealtype, sunrealtype**, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:167</i>
	 */
	void SUNDlsMat_denseScale(sunrealtype c, sunrealtype a[], sunindextype m, sunindextype n);
	/**
	 * Original signature : <code>void SUNDlsMat_denseScale(sunrealtype, sunrealtype**, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:167</i>
	 */
	void SUNDlsMat_denseScale(sunrealtype c, sunrealtype a[], Pointer m, Pointer n);
	/**
	 * -----------------------------------------------------------------------------<br>
	 * Function: SUNDlsMat_denseAddIdentity<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_denseAddIdentity adds the identity matrix to the n-by-n matrix<br>
	 * stored in a sunrealtype** array.<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_denseAddIdentity(sunrealtype**, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:180</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseAddIdentity(sunrealtype[], sunindextype)} and {@link #SUNDlsMat_denseAddIdentity(sunrealtype[], Pointer)} instead
	 */
	@Deprecated 
	void SUNDlsMat_denseAddIdentity(PointerByReference a, Pointer n);
	/**
	 * -----------------------------------------------------------------------------<br>
	 * Function: SUNDlsMat_denseAddIdentity<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_denseAddIdentity adds the identity matrix to the n-by-n matrix<br>
	 * stored in a sunrealtype** array.<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_denseAddIdentity(sunrealtype**, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:180</i>
	 */
	void SUNDlsMat_denseAddIdentity(sunrealtype a[], sunindextype n);
	/**
	 * -----------------------------------------------------------------------------<br>
	 * Function: SUNDlsMat_denseAddIdentity<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_denseAddIdentity adds the identity matrix to the n-by-n matrix<br>
	 * stored in a sunrealtype** array.<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_denseAddIdentity(sunrealtype**, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:180</i>
	 */
	void SUNDlsMat_denseAddIdentity(sunrealtype a[], Pointer n);
	/**
	 * -----------------------------------------------------------------------------<br>
	 * Function: SUNDlsMat_DenseMatvec<br>
	 * -----------------------------------------------------------------------------<br>
	 * SUNDlsMat_DenseMatvec computes the matrix-vector product y = A*x, where A is<br>
	 * an M-by-N matrix, x is a vector of length N, and y is a vector of length M.<br>
	 * No error checking is performed on the length of the arrays x and y.  Only y<br>
	 * is modified in this routine.<br>
	 * SUNDlsMat_DenseMatvec is a wrapper around SUNDlsMat_denseMatvec which<br>
	 * performs the actual product by accessing the data in the SUNDlsMat A.<br>
	 * -----------------------------------------------------------------------------<br>
	 * Original signature : <code>void SUNDlsMat_DenseMatvec(SUNDlsMat, sunrealtype*, sunrealtype*)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:197</i>
	 */
	void SUNDlsMat_DenseMatvec(_DlsMat A, sunrealtype x, sunrealtype y);
	/**
	 * Original signature : <code>void SUNDlsMat_denseMatvec(sunrealtype**, sunrealtype*, sunrealtype*, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:200</i><br>
	 * @deprecated use the safer methods {@link #SUNDlsMat_denseMatvec(sunrealtype[], sunrealtype, sunrealtype, sunindextype, sunindextype)} and {@link #SUNDlsMat_denseMatvec(sunrealtype[], sunrealtype, sunrealtype, Pointer, Pointer)} instead
	 */
	@Deprecated 
	void SUNDlsMat_denseMatvec(PointerByReference a, sunrealtype x, sunrealtype y, Pointer m, Pointer n);
	/**
	 * Original signature : <code>void SUNDlsMat_denseMatvec(sunrealtype**, sunrealtype*, sunrealtype*, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:200</i>
	 */
	void SUNDlsMat_denseMatvec(sunrealtype a[], sunrealtype x, sunrealtype y, sunindextype m, sunindextype n);
	/**
	 * Original signature : <code>void SUNDlsMat_denseMatvec(sunrealtype**, sunrealtype*, sunrealtype*, sunindextype, sunindextype)</code><br>
	 * <i>native declaration : include\sundials\sundials_dense.h:200</i>
	 */
	void SUNDlsMat_denseMatvec(sunrealtype a[], sunrealtype x, sunrealtype y, Pointer m, Pointer n);
	public static class N_Vector_Ops extends PointerType {
		public N_Vector_Ops(Pointer address) {
			super(address);
		}
		public N_Vector_Ops() {
			super();
		}
	};
}
